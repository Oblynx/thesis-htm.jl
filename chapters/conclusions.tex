\section{Δημοσίευση πακέτου \texttt{HierarchicalTemporalMemory.jl}}

	Στο πλαίσιο αυτής της εργασίας, ακολουθώντας την υλοποίηση του κεφαλαίου \ref{impl} και επαυξάνοντας πάνω σε αυτήν,
	δημιουργήθηκε πακέτο Julia που υλοποιεί τους 2 αλγορίθμους HTM που περιγράφηκαν.
	Δημοσιεύεται ως ελεύθερο λογισμικό \parencite{stallmanFreeSoftwareFree2002} στο Github\footnote{Ημερομηνία δημοσίευσης: 2019/06/09}:
	\url{https://github.com/Oblynx/HierarchicalTemporalMemory.jl}

	Η ανάπτυξη θα συνεχιστεί πέρα από το πλαίσιο αυτής της εργασίας.

\subsection{Συνεισφορές στο οικοσύστημα της Julia («upstream»)}

	\subsubsection{Διόρθωση στον πολλαπλασιασμό αραιού πίνακα με διάνυσμα}

	Η υλοποίηση της χρονικής μνήμης βασίστηκε στους αραιούς πίνακες.
	Η υποστήριξη των αραιών πινάκων στη Julia, αν και επαρκής για βασική χρήση, αφήνει μερικά κενά.
	Ένα τέτοιο διαπιστώθηκε κατά την εκπόνηση αυτής της εργασίας.

	Έστω αραιός πίνακας με τιμές Bool, \texttt{S::SparseMatrixCSC{Bool}},
	και πυκνό διάνυσμα Bool, \texttt{a::Vector{Bool}}.
	Ενώ εν γένει ο πολλαπλασιασμός αραιού πίνακα με πυκνό διάνυσμα υποστηρίζεται, αυτός ο συγκεκριμένος συνδυασμός τύπων δημιουργούσε πρόβλημα.
	Ο πολλαπλασιασμός κατά προεπιλογή πραγματοποιείται στον ημιδακτύλιο (+,*).
	Οι τελεστές αυτοί δεν έχουν ειδικό νόημα για τιμές Bool: \texttt{Bool + Bool} προκαλεί μετατροπή των ορισμάτων σε \texttt{Int} και εκτελεί εν τέλει \texttt{Int(Bool) + Int(Bool)}
	\footnote{ Δεν είναι δύσκολο να οριστεί ο πολλαπλασιασμός του αραιού πίνακα με το διάνυσμα σε διαφορετικό ημιδακτύλιο, πχ (max,min) --
	για την ακρίβεια αυτό ακριβώς παρουσιάζεται στο \cite{shahNovelAlgebrasAdvanced2013}, όπου δείχνεται ότι, για αραιούς πίνακες,
	η υλοποίηση από το χρήστη είναι πέρα από εύκολη και \textbf{εξίσου αποδοτική με τον τυπικό πολλαπλασιασμό που ορίζουν οι βασικές βιβλιοθήκες της γλώσσας} }.
	Επειδή και ο πίνακας και το διάνυσμα που συμμετέχουν στον πολλαπλασιασμό έχουν τύπο στοιχείου Bool,
	η συνάρτηση του πολλαπλασιασμού εσφαλμένα απέδιδε στο αποτέλεσμα τύπο στοιχείου Bool.
	Το επακόλουθο ήταν ο πολλαπλασιασμός $S*a$ να προκαλεί σφάλμα.
	Η προφανής επίλυση είναι η αλλαγή του τύπου του αποτελέσματος σε αυτό που προκύπτει από τις πράξεις μεταξύ των στοιχείων των ορισμάτων, εδώ \texttt{Int}.

	Καθώς η Julia αναπτύσσεται ως ελεύθερο λογισμικό, κατέστη εφικτό στο πλαίσιο αυτής της εργασίας να διορθωθεί αυτό το σφάλμα στην πηγή του.
	Η διόρθωση υποβλήθηκε ως «pull request» \footnote{\url{https://github.com/JuliaLang/julia/pull/32082}} και έγινε δεκτή.

	\subsubsection{Διόρθωση στο χειρισμό Unicode στο \texttt{Weave.jl}}

	Το κεφάλαιο \ref{impl} αυτής της αναφοράς συγγράφηκε με τη μεθοδολογία \textbf{«literate programming»} \parencite{knuthLiterateProgramming1984},
	που εμπλέκει λειτουργικό κώδικα και αφηγηματικό κείμενο,
	χρησιμοποιώντας το πακέτο της Julia \texttt{Weave.jl} \cite{pastellWeaveJlScientific2017}.
	Έγινε εκτενής χρήση χαρακτήρων Unicode που υποστηρίζονται από τη Julia, τόσο στο κείμενο όσο και στον κώδικα.
	Οι χαρακτήρες Unicode κωδικοποιούνται υπό το πρότυπο UTF-8, μια κωδικοποίηση μεταβλητού μήκους.

	Κατά τη δημιουργία της αναφοράς παρατηρήθηκε πρόβλημα στον τρόπο με τον οποίο το Weave.jl ερμήνευε τους χαρακτήρες Unicode.
	Από εκφράσεις με πολύ ειδικούς χαρακτήρες έλειπε το τελευταίο τμήμα.
	Διαπιστώθηκε λοιπόν ότι κατά την ανάγνωση του κειμένου το \texttt{Weave.jl} δε λάμβανε υπόψιν το μεταβλητό μήκος των χαρακτήρων UTF-8,
	θεωρώντας εσφαλμένα ότι κάθε χαρακτήρας έχει το ίδιο μήκος.
	Καθώς και αυτό είναι ανοιχτό λογισμικό, το σφάλμα επίσης διορθώθηκε στην πηγή του
	\footnote{\url{https://github.com/mpastell/Weave.jl/pull/215}}.
	Κατά τη συγγραφή αυτής της αναφοράς η αποδοχή της διόρθωσης εκκρεμεί.


\subsection{Παράδειγμα πρόβλεψης ακολουθίας} \label{conc:intro-tspred}

	Το πακέτο συμπεριλαμβάνει μία απλή εφαρμογή πρόβλεψης ακολουθίας, που χρησιμοποιήθηκε ως βασικός έλεγχος ορθότητας της υλοποίησης.
	Επομένως περιέχει τα υπόλοιπα στοιχεία που χρειάζεται ένα σύστημα πρόβλεψης με HTM και φαίνονται στο σχήμα (\ref{fig:sp}, πάνω):
	έναν κωδικοποιητή κι έναν αποκωδικοποιητή/κατηγοριοποιητή.

	Ο κωδικοποιητής αναπαριστά πραγματικούς αριθμούς φραγμένους σε ένα εύρος, δημιουργώντας SDR με μήκος N και πληθάριθμο w.
	Ο ελάχιστος αριθμός του εύρους αναπαρίσταται με το SDR που έχει τα w πρώτα bits ενεργά, αντίστοιχα ο μέγιστος έχει τα w τελευταία ενεργά.
	Κάθε ενδιάμεσος αριθμός αντιστοιχίζεται σε ένα ισοκατανεμημένο φάσμα μεταξύ των δύο ακραίων αναπαραστάσεων,
	ορίζοντας ουσιαστικά ένα σύνολο κλάσεων που διακριτοποιούν την είσοδο.
	Ο κωδικοποιητής αυτός ονομάζετα «απλός αριθμητικός».

	Η συγκόλληση k SDR στη σειρά για μικρό k (πχ 2-7) είναι επαρκής τρόπος για τη συνδυασμένη αναπαράσταση k εισόδων.
	Οι διακριτές είσοδοι που συνδυάζονται με αυτήν την απλή λογική δεν μπορούν να είναι οσοδήποτε πολλές,
	γιατί η διάσταση του χώρου της εισόδου θα αυξηθεί πολύ πιο γρήγορα από την αύξηση της πληροφορίας που φέρει,
	δυσχεραίνοντας την αναγνώριση παρόμοιων εισόδων.
	Στο συνδυασμό πολλών εισόδων το κλειδί ενδέχεται να είναι η ιεραρχικη οργάνωση πολλών μονάδων HTM,
	που θα αναλυθεί στις προτάσεις για μελέτη \ref{conc:study-suggestions}.

	\subsubsection{Αποκωδικοποιητής «SDR classifier»}

	Ο αποκωδικοποιητής, που ονομάζεται «SDR classifier» \parencite{cuiContinuousOnlineSequence2016},
	βασίζεται στην παρατήρηση ότι η δραστηριότητα της χρονικής μνήμης είναι η απεικόνιση ενός συμβόλου-εισόδου στο πλαίσιο των χρονικών του συμφραζομένων.
	Ο αποκωδικοποιητής που χρησιμοποιείται εδώ είναι ένα απλό ενός επιπέδου perceptron πολλών κλάσεων που μαθαίνει να συσχετίζει
	τη δραστηριότητα της χρονικής μνήμης με τις εισόδους του κωδικοποιητή.
	Η είσοδος είναι το διάνυσμα $Π$ των προβλέψεων της χρονικής μνήμης κι η έξοδος, κατανομή πιθανότητας πάνω στις κλάσεις του κωδικοποιητή.

	Έστω ο αποκωδικοποιητής $D$ καλείται να αποκωδικοποιήσει την πρόβλεψη $Π_t$, επιστρέφοντας
	$D(Π_t)$.
	Έστω επίσης ότι η πρόβλεψη αφορά την τιμή της εισόδου $k$ χρονικές στιγμές στο μέλλον,
	$u_{t+k}$.
	Τη στιγμή $t+k$, ο αποκωδικοποιητής θα χρησιμοποιήσει το σφάλμα $e_{t+k} = D(Π_t) - u_{t+k}$
	για να τροποποιήσει τον πίνακα βαρών $W$ του δικτύου του κατά
	$$ ΔW= -α .* e_{t+k}*Π[Π]' $$

	Για την ερμηνεία της κατανομής πιθανότητας στις κλάσεις του κωδικοποιητή απαιτείται και ένας μηχανισμός αποσαφήνισης.
	Παρέχονται 3 τέτοιοι: πιθανότερο ενδεχόμενο, μέσος όρος, μέσος όρος των πιθανότερων ενδεχομένων.


\section{Επαλήθευση βασικών ιδιοτήτων των αλγορίθμων}

\subsection{Διατήρηση σημασιολογικής ομοιότητας στο χωρικό συγκεντρωτή}

Όπως περιγράφηκε στην ενότητα \ref{htm:sp}, αρχή λειτουργίας του χωρικού συγκεντρωτή είναι η διατήρηση της ομοιότητας των εισόδων στις εξόδους του.
Δηλαδή, είσοδοι που μοιάζουν πολύ πρέπει να οδηγούν σε εξόδους που μοιάζουν πολύ και αντιστρόφως.

Έστω 3 είσοδοι $x_1, x_2, x_3$ κι οι αντίστοιχες έξοδοι $y_1, y_2, y_3$
και «overlap score» (βλέπε \ref{htm:sdr}) $\mathit{sx}_{i,j}= ||x_i ∩ x_j||$, $\mathit{sy}_{i,j}= ||y_i ∩ y_j||$,

Έστω $\mathit{sx}_{1,2} >> \mathit{sx}_{1,3}$.
Τότε θα πρέπει και $\mathit{sy}_{1,2} >> \mathit{sy}_{1,3}$.

Αυτή η ιδιότητα εξετάζεται στο \texttt{HierarchicalTemporalMemory.jl} ως ένδειξη για την ορθότητα του χωρικού συγκεντρωτή,
καθώς παρακολουθεί και μαθαίνει μία χρονοσειρά της ωριαίας κατανάλωσης ηλεκτρικής ισχύος ενός γυμναστηρίου.
Το συγκεκριμένο σύνολο δεδομένων προτιμήθηκε καθώς αποτελεί παράδειγμα αναφοράς για την ικανότητα πρόβλεψης στους αλγορίθμους HTM.


\section{Τι αξίζει να μελετηθεί στην HTM;} \label{conc:study-suggestions}
