# Î£ÏÎ½Î¸ÎµÏƒÎ· ÏƒÏ„Î¿Î¹Ï‡ÎµÎ¯Ï‰Î½ Ï‡Ï‰ÏÎ¹ÎºÎ¿Ï ÏƒÏ…Î³ÎºÎµÎ½Ï„ÏÏ‰Ï„Î®

Î¤Î¿ Î¼ÏŒÎ½Î¿ ÎµÎ¼Ï€ÏŒÎ´Î¹Î¿ Ï€Î¿Ï… Î¼Î­Î½ÎµÎ¹ Î³Î¹Î± Ï„Î· Ï‡ÏÎ®ÏƒÎ· Ï„Î¿Ï… Ï‡Ï‰ÏÎ¹ÎºÎ¿Ï ÏƒÏ…Î³ÎºÎµÎ½Ï„ÏÏ‰Ï„Î® ÎµÎ¯Î½Î±Î¹ ÏŒÏ„Î¹ Î¿Î¹ Ï€ÏÎ¿Î·Î³Î¿ÏÎ¼ÎµÎ½Î¿Î¹ Î¿ÏÎ¹ÏƒÎ¼Î¿Î¯ Ï‡ÏÎ·ÏƒÎ¹Î¼Î¿Ï€Î¿Î¹Î¿ÏÏƒÎ±Î½ Â«globalÂ» Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î­Ï‚
Î³Î¹Î± Ï„Î·Î½ ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ· ÎºÎ±Î¹ Î³Î¹Î± Ï„Î¹Ï‚ Ï€Î±ÏÎ±Î¼Î­Ï„ÏÎ¿Ï…Ï‚.
Î‘Ï…Ï„ÏŒ Î²Î¿Î®Î¸Î·ÏƒÎµ Î½Î± Î±Ï€Î»Î¿Ï€Î¿Î¹Î®ÏƒÎ¿Ï…Î¼Îµ Ï„Î·Î½ Ï€ÎµÏÎ¹Î³ÏÎ±Ï†Î® Ï„Î¿Ï… Î±Î»Î³Î¿ÏÎ¯Î¸Î¼Î¿Ï…, Î±Î»Î»Î¬ ÏŒÏ‡Î¹ Ï„Î· Ï‡ÏÎ®ÏƒÎ· Ï„Î¿Ï… Ï‰Ï‚ Î²Î¹Î²Î»Î¹Î¿Î¸Î®ÎºÎ·.
ÎšÎ±Î¸ÏÏ‚ Î¿ Î­Î»ÎµÎ³Ï‡Î¿Ï‚ Ï„Î·Ï‚ ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ·Ï‚ ÎµÎ¯Î½Î±Î¹ ÎºÏÎ¯ÏƒÎ¹Î¼Î¿Ï‚ Î³Î¹Î± Ï„Î· ÏƒÏ…Î¼Ï€ÎµÏÎ±ÏƒÎ¼Î±Ï„Î¿Î»Î¿Î³Î¯Î± ÏƒÎµ Î¿Ï€Î¿Î¹Î¿Î´Î®Ï€Î¿Ï„Îµ Ï€ÏÏŒÎ³ÏÎ±Î¼Î¼Î±,
Î¸Î± Ï€ÏÎ­Ï€ÎµÎ¹ ÏŒÎ»ÎµÏ‚ Î¿Î¹ Â«globalÂ» Î¼ÎµÏ„Î±Î²Î»Î·Ï„Î­Ï‚ Î½Î± ÎµÎ¾Î±Î»ÎµÎ¹Ï†Î¸Î¿ÏÎ½.
ÎŸÎ¹ Ï„ÏÏŒÏ€Î¿Î¹ Î±Î½Ï„Î¹Î¼ÎµÏ„ÏÏ€Î¹ÏƒÎ·Ï‚ ÎµÎ¯Î½Î±Î¹:
- Î½Î± Ï€ÎµÏÎ¹ÎºÎ»ÎµÎ¯ÏƒÎ¿Ï…Î¼Îµ Ï„Î¿Î½ Î¿ÏÎ¹ÏƒÎ¼ÏŒ Ï„Ï‰Î½ Ï€ÎµÏÎ¹ÏƒÏƒÏŒÏ„ÎµÏÏ‰Î½ ÎµÎ¾ÎµÎ¹Î´Î¹ÎºÎµÏ…Î¼Î­Î½Ï‰Î½ ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÏ‰Î½ ÎµÎ½Ï„ÏŒÏ‚ Ï„Î¿Ï… Ï€ÎµÎ´Î¯Î¿Ï… Î³ÎµÎ½Î¹ÎºÏŒÏ„ÎµÏÏ‰Î½ ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÏ‰Î½, ÏŒÏ€Î¿Ï… Î¸Î± Î­Ï‡Î¿Ï…Î½ Î­Î¼Î¼ÎµÏƒÎ· Ï€ÏÏŒÏƒÎ²Î±ÏƒÎ· ÏƒÏ„Î± ÏƒÏÎ¼Î²Î¿Î»Î± Ï€Î¿Ï… Î¿ÏÎ¯Î¶Î¿Ï…Î½ Î¿Î¹ Ï€ÎµÏÎ¹ÎºÎ»ÎµÎ¯Î¿Ï…ÏƒÎµÏ‚
- Î½Î± Î´ÏÏƒÎ¿Ï…Î¼Îµ ÏƒÏ„Î¹Ï‚ Î³ÎµÎ½Î¹ÎºÏŒÏ„ÎµÏÎµÏ‚ ÏƒÏ…Î½Î±ÏÏ„Î®ÏƒÎµÎ¹Ï‚ Ï€Î¿Ï… Î¼ÎµÎ½Î¿Ï…Î½ ÎµÏ€Î¹Ï€Î»Î­Î¿Î½ Î¿ÏÎ¯ÏƒÎ¼Î±Ï„Î±

_ÎŸÎ¹ Î¿ÏÎ¹ÏƒÎ¼Î¿Î¯ Ï€Î¿Ï… Î´Î¯Î½Î¿Î½Ï„Î±Î¹ Ï€Î±ÏÎ±ÎºÎ¬Ï„Ï‰ ÏƒÏ…Î³ÎºÎµÎ½Ï„ÏÏÎ½Î¿Ï…Î½ ÏŒÎ»Î· Ï„Î·Î½ Ï…Î»Î¿Ï€Î¿Î¯Î·ÏƒÎ· Ï„Î¿Ï… Ï‡Ï‰ÏÎ¹ÎºÎ¿Ï ÏƒÏ…Î³ÎºÎµÎ½Ï„ÏÏ‰Ï„Î® ÎºÎ±Î¹ ÏƒÏ„Î­ÎºÎ¿Ï…Î½ Î±Ï…Ï„ÏŒÎ½Î¿Î¼Î± Î±Ï€ÏŒ Ï„Î¿Ï…Ï‚ Ï€ÏÎ¿Î·Î³Î¿ÏÎ¼ÎµÎ½Î¿Ï…Ï‚._
Î”Îµ Î³Î¯Î½ÎµÏ„Î±Î¹ ÎºÎ±Î¼Î¯Î± Î±Î»Î»Î±Î³Î® ÏƒÏ„Î¿Ï…Ï‚ Î±Î»Î³Î¿ÏÎ¯Î¸Î¼Î¿Ï…Ï‚.

ÎŸÏÎ¹ÏƒÎ¼Î¿Î¯ ÏƒÏ„Î±Î¸ÎµÏÏÎ½ ÎºÎ±Î¹ Ï„ÏÏ€Ï‰Î½ Ï…Ï€Î¿Î´Î¿Î¼Î®Ï‚:
```julia; results= "hidden"
using Random
using Parameters
import Lazy: @>, @>>
import StatsBase: mean, median
import ImageFiltering: mapwindow, Fill, imfilter
# Constants
const ğ•Šğ•¢= UInt8
const ğ•Šğ•¢range= ğ•Šğ•¢(0):typemax(ğ•Šğ•¢)
# Topology
struct Hypercube{N}
  xá¶œ::NTuple{N,Int}
  Î³::Int
  sz::NTuple{N,Int}
  indices::CartesianIndices{N}
end
Hypercube(xá¶œ,Î³,sz)= Hypercube(xá¶œ,Î³,sz, start(xá¶œ,Î³,sz))
start(xá¶œ,Î³,sz)= CartesianIndices(map( (a,b)-> a:b,
                    max.(xá¶œ .- Î³, 1),
                    min.(xá¶œ .+ Î³, sz) ))
Base.iterate(hc::Hypercube)= begin
  i= iterate(hc.indices)
  !isnothing(i) ? (i[1].I,i[2]) : nothing
end
Base.iterate(hc::Hypercube,state)= begin
  i= iterate(hc.indices,state)
  !isnothing(i) ? (i[1].I,i[2]) : nothing
end
Base.length(hc::Hypercube)= length(hc.indices)
Base.size(hc::Hypercube)= size(hc.indices)
# Infrastructure
â„“(sz)= prod(sz)
step!(s::Symbol,args...)= step!(Val(s),args...)
```

Î‘Ï‚ ÏƒÏ…Î½Î¸Î­ÏƒÎ¿Ï…Î¼Îµ Ï„Î·Î½ Î±ÏÏ‡Î¹ÎºÎ¿Ï€Î¿Î¯Î·ÏƒÎ· Ï„Î·Ï‚ ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ·Ï‚ ÎºÎ±Î¹ Ï„Î¹Ï‚ Ï€Î±ÏÎ±Î¼Î­Ï„ÏÎ¿Ï…Ï‚.
```julia; results= "hidden"
@with_kw struct SPParams{Nin,Nsp}
  száµ¢â‚™::NTuple{Nin,Int}    = (32,32); @assert all(száµ¢â‚™.>0)
  szâ‚›â‚š::NTuple{Nsp,Int}    = (64,64); @assert all(szâ‚›â‚š.>0)
  Î³::Int                   = 6;       @assert Î³>0
  Ï†::Float32               = Î³*mean(szâ‚›â‚š./száµ¢â‚™)
  s::Float32               = .02;     @assert s>0
  Î¸_potential_prob::Float32= .5;      @assert 0<=Î¸_potential_prob<=1
  Î¸_permanence01           = .5;      @assert 0<=Î¸_permanence01<=1
  pâº_01                    = .1;      @assert 0<=pâº_01<=1
  pâ»_01                    = .02;     @assert 0<=pâ»_01<=1
  Î¸_permanence::ğ•Šğ•¢       = @>> Î¸_permanence01*typemax(ğ•Šğ•¢) round(ğ•Šğ•¢)
  pâº::ğ•Šğ•¢                 = round(ğ•Šğ•¢, pâº_01*typemax(ğ•Šğ•¢))
  pâ»::ğ•Šğ•¢                 = round(ğ•Šğ•¢, pâ»_01*typemax(ğ•Šğ•¢))
  Î¸_stimulus_activate::Int = 1;       @assert Î¸_stimulus_activate>=0
  Tboost::Float32          = 200;     @assert Tboost>0
  Î²::Float32               = 1;       @assert Î²>0
  @assert Ï†>=1
  @assert zero(ğ•Šğ•¢)<=Î¸_permanence<=typemax(ğ•Šğ•¢)
  @assert zero(ğ•Šğ•¢)<=pâº<=typemax(ğ•Šğ•¢)
  @assert zero(ğ•Šğ•¢)<=pâ»<=typemax(ğ•Šğ•¢)
end
struct SpatialPooler{Nin,Nsp}
  params::SPParams{Nin,Nsp}
  Dâ‚š::Matrix{ğ•Šğ•¢}
  Ã¥â‚œ::Array{Float32,Nsp}

  SpatialPooler(params::SPParams{Nin,Nsp}) where {Nin,Nsp}= begin
    @unpack száµ¢â‚™,szâ‚›â‚š,Î¸_potential_prob,Î³ = params

    xá¶œ(yáµ¢)= floor.(Int, (yáµ¢.-1) .* (száµ¢â‚™./szâ‚›â‚š)) .+1
    xáµ¢(xá¶œ)= Hypercube(xá¶œ,Î³,száµ¢â‚™)
    Î¸_effective()= floor(ğ•Šğ•¢, (1 - Î¸_potential_prob)*typemax(ğ•Šğ•¢))
    out_lattice()= (c.I for c in CartesianIndices(szâ‚›â‚š))
    permanences(xáµ¢)= begin
      # Decide randomly if yáµ¢ âŸ· xáµ¢ will connect
      p= rand(ğ•Šğ•¢range,length(xáµ¢))
      p0= p .> Î¸_effective(); pScale= p .< Î¸_effective()
      p[p0].= ğ•Šğ•¢(0)
      # Draw permanences from uniform distribution in ğ•Šğ•¢
      p[pScale].= rand(ğ•Šğ•¢range, count(pScale))
      return p
    end
    fillin_permanences()= begin
      Dâ‚š= zeros(ğ•Šğ•¢, â„“(száµ¢â‚™),â„“(szâ‚›â‚š))
      foreach(out_lattice()) do yáµ¢
        # Linear indices from hypercube
        x= @>> yáµ¢ xá¶œ xáµ¢ collect map(x->c2láµ¢â‚™[x...])
        Dâ‚š[x, c2lâ‚›â‚š[yáµ¢...]]= permanences(@> yáµ¢ xá¶œ xáµ¢)
      end
      return Dâ‚š
    end
    c2láµ¢â‚™= LinearIndices(száµ¢â‚™)
    c2lâ‚›â‚š= LinearIndices(szâ‚›â‚š)

    new{Nin,Nsp}(params,
                 fillin_permanences(),
                 zeros(szâ‚›â‚š...))
  end
end
```

Î— ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· ÎµÎ½ÎµÏÎ³Î¿Ï€Î¿Î¯Î·ÏƒÎ·Ï‚ Î³Î¯Î½ÎµÏ„Î±Î¹:
```julia; results= "hidden"
sp_activate(z,sp::SpatialPooler{Nin,Nsp}) where {Nin,Nsp}= begin
  @unpack szâ‚›â‚š,s,Ï†,Î²,Î¸_permanence,Î¸_stimulus_activate = sp.params
  @unpack Dâ‚š,Ã¥â‚œ = sp
  # overlap
  Wâ‚š()=  Dâ‚š .> Î¸_permanence
  o(z)=  @> (b() .* Wâ‚š()'z) reshape(szâ‚›â‚š)
  # inhibition
  Î±(Ï†)=  2round(Int,Ï†)+1
  k()=   ceil(Int, s*Î±(Ï†)^Nsp)
  z!(X)= @> X vec partialsort!(k(),rev=true)
  Z(o)=  mapwindow(z!, o, window(), border= Fill(0))
  # boosting
  window()= ntuple(i->Î±(Ï†),Nsp)
  mean_kernel()= ones(window()) ./ Î±(Ï†).^Nsp
  Ã¥â‚™()=  imfilter(Ã¥â‚œ, mean_kernel(), "symmetric")
  b()=   @> exp.(-Î² .* (Ã¥â‚œ .- Ã¥â‚™())) vec

  activate(o)= ((o .>= Z(o)) .& (o .> Î¸_stimulus_activate))|> vec
  z|> o|> activate
end
```

Î‘Ï‚ ÏƒÏ…Î½Î¸Î­ÏƒÎ¿Ï…Î¼Îµ Ï„Î· ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· Î²Î®Î¼Î±Ï„Î¿Ï‚ Ï„Î¿Ï… Ï‡Ï‰ÏÎ¹ÎºÎ¿Ï ÏƒÏ…Î³ÎºÎµÎ½Ï„ÏÏ‰Ï„Î®.
Î— ÏƒÏ…Î½Î¬ÏÏ„Î·ÏƒÎ· Î»Î±Î¼Î²Î¬Î½ÎµÎ¹ Ï„Î·Î½ ÎµÎ¯ÏƒÎ¿Î´Î¿, Ï…Ï€Î¿Î»Î¿Î³Î¯Î¶ÎµÎ¹ Ï„Î·Î½ ÎµÎ½ÎµÏÎ³Î¿Ï€Î¿Î¯Î·ÏƒÎ· ÎºÎ±Î¹ Ï€ÏÎ±Î³Î¼Î±Ï„Î¿Ï€Î¿Î¹ÎµÎ¯ Ï„Î¹Ï‚ Î±Ï€Î±Î¹Ï„Î¿ÏÎ¼ÎµÎ½ÎµÏ‚ Î¼ÎµÏ„Î±Î²Î¿Î»Î­Ï‚ ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ·Ï‚.
```julia; results= "hidden"
step!(::Val{:sp}, sp,z)= begin
  a= sp_activate(z,sp)
  step!(:Ã¥â‚œ, sp,a)
  step!(:Dâ‚š, sp,z,a)
  return a
end
step!(::Val{:Ã¥â‚œ}, sp,a)= begin
  @unpack Tboost, szâ‚›â‚š = sp.params
  sp.Ã¥â‚œ.= (sp.Ã¥â‚œ.*(Tboost-1) .+ reshape(a,szâ‚›â‚š))./Tboost
end
step!(::Val{:Dâ‚š}, sp,z,a)= learn!(sp.Dâ‚š,z,a,sp.params)
learn!(Dâ‚š,z,a,params)= begin
  @unpack pâº,pâ» = params
  Dâ‚šactive= @view Dâ‚š[:,a]   # the only elements we touch
  activeConn=   (Dâ‚šactive .> 0) .&   z
  inactiveConn= (Dâ‚šactive .> 0) .& .!z
  Dâ‚šactive.= activeConn   .* (Dâ‚šactive .âŠ• pâº) .+
             inactiveConn .* (Dâ‚šactive .âŠ– pâ»)
end
# saturated arithmetic
âŠ•(a::T,b::T) where {T<:Unsigned}= a+b>a ? a+b : typemax(T)
âŠ–(a::T,b::T) where {T<:Unsigned}= a-b<a ? a-b : one(T)
âŠ•(a::T,b::T) where {T<:Signed}= a+b>a ? a+b : typemax(T)
âŠ–(a::T,b::T) where {T<:Signed}= a-b>0 ? a-b : one(T)
```
