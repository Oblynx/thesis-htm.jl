# Υλοποίηση του χωρικού συγκεντρωτή

Στην ενότητα ``@\ref{htm:sp}@`` περιγράφηκε ο αλγόριθμος του χωρικού συγκεντρωτή.
Εδώ θα ακολουθήσουμε τη σχεδίαση της υλοποίησής του σε Julia.

## Χώροι εισόδου και εξόδου

Ο χωρικός συγκεντρωτής εμπλέκει ένα ``N_{in}``-διάστατο πεπερασμένο διακριτό πλέγμα στην είσοδο με ένα
``N_{sp}``-διάστατο πεπερασμένο διακριτό πλέγμα στην έξοδο, που αντιπροσωπεύουν τα φλοιικά επίπεδα με κάθε
πλεγματική κορυφή να αντιστοιχίζεται σε μία μικροστήλη.
Το μέγεθος του πλέγματος εισόδου είναι ``\mathit{sz_{in}} \in \mathbb{R}^{N_{in}}``
και του πλέγματος εξόδου ``\mathit{sz_{sp}} \in \mathbb{R}^{N_{sp}}``.
Με βάση αυτό ορίζουμε το μήκος των δύο πλεγμάτων ως ``ℓ_i = \prod \mathit{sz_i}``

Ας ορίσουμε κάποιες διαστάσεις για να χτίσουμε ένα παράδειγμα:
```julia; results= "hidden"
Νᵢₙ= 2
Nₛₚ= 2
szᵢₙ= (5,5)
szₛₚ= (6,9)
```

### Ορισμός συνάρτησης που δέχεται σύμβολα ως όρισμα

Ορίσαμε τις διαστάσεις των πλεγμάτων ως σταθερές. Το μήκος των πλεγμάτων όμως δε χρειάζεται να είναι νέες, ανεξάρτητες σταθερές.
Μπορεί να είναι συνάρτηση του ονόματος της διάστασης, ώστε, αν αλλάξουμε τη διάσταση, να αλλάξει και το μήκος.
Ιδανικά, θα θέλαμε να γράφουμε:
```
julia> ℓ(:in)
64

julia> szᵢₙ= (2,40)
(2,40)

julia> ℓ(:in)
80
```

Ο πιο απλός τρόπος να το καταφέρουμε αυτό είναι ο εξής:
```julia; term= true
ℓ(s::Symbol)= if s === :in
  prod(szᵢₙ)
elseif s === :sp
  prod(szₛₚ)
else
  error("Undefined symbol")
end
ℓ(:in)
ℓ(:sp)
```
```julia; tangle= false
ℓ(:random_symbol)
```
Παραπάνω χρησιμοποιήθηκε ο τελεστής της ταύτισης `===`, αντί για τον τελεστή της ισότητας `==`.
Εν προκειμένω θα συμπεριφέρονταν εξίσου, γιατί τα σύμβολα είναι «μοναδικές» (singleton) τιμές.

Ένας εναλλακτικός τρόπος:
```julia; term= true
ℓ(::Val{:in})= prod(szᵢₙ)
ℓ(::Val{:sp})= prod(szₛₚ)
ℓ(s::Symbol)= ℓ(Val(s))
ℓ(:in)
ℓ(:sp)
```
Ο δεύτερος ορισμός χρησιμοποιεί πιο σύνθετα στοιχεία της γλώσσας: παραμετρικούς τύπους και πολλαπλή αποστολή για να επιλέξει τη σωστή μέθοδο (βλέπε ``@\ref{intro:julia_struct}@``).
Ωστόσο, προσφέρει ένα σημαντικό πλεονέκτημα.

Αν θέλουμε να ορίσουμε επιπλέον συμπεριφορά της συνάρτησης για ένα νέο σύμβολο, έστω `:random_symbol`, δε χρειάζεται να ανατρέξουμε στον κώδικα στο σημείο ορισμου της μεθόδου
`ℓ(::Symbol)` και να την τροποποιήσουμε ``@\char"0387@``
αρκεί να ορίσουμε μία νέα μέθοδο:
```julia; term= true
ℓ(::Val{:random_symbol})= rand()
ℓ(:random_symbol)
ℓ(:random_symbol)
```

Καταδεικνύεται έτσι μια βασική σχεδιαστική αρχή στη Julia που βοηθά στην απόπλεξη του κώδικα:
προτιμούμε να ορίζουμε πολλές μικρές μεθόδους και τύπους-περικαλύμματα (wrapping types), όπως εδώ ο `Val`.
``@\bigskip@``

Έστω ``\mathbb{B} = \{0,1\}`` το σύνολο των λογικών τιμών, οπότε ``x \in \mathbb{B}^N``
είναι ένα δυαδικό διάνυσμα μήκους N.

Έστω τα ερεθίσματα εισόδου ``z \in \mathbb{B}^{ℓ_{in}}``
και εξόδου ``a \in \mathbb{B}^{ℓ_{sp}}``.
Τα ``z,a`` αντιστοιχίζουν τα ερεθίσματα με τις κορυφές του πλέγματος, αν ξεδιπλώσουμε
τις διαστάσεις των πλεγμάτων με τη σειρά (column-major).

```julia; results= "hidden"
using Random
z= bitrand(ℓ(:in))
```

### Αντιστοίχιση χώρων εισόδου-εξόδου

Οι μικροστήλες της εισόδου και της εξόδου αντιστοιχίζονται μεταξύ τους μέσω των εγγύς συνάψεων των νευρώνων τους.
Η j-οστή μικροστήλη εισόδου συμβολίζεται ``x_j`` κι η i-οστή μικροστήλη εξόδου ``y_i``.
Ο χώρος της εισόδου θεωρείται στη γενική περίπτωση ότι έχει τοπολογία, η οποία πρέπει να διατηρηθεί στο χώρο εξόδου.
Για αυτό, κάθε ``y_i`` αντιστοιχίζεται σε μία περιοχή της εισόδου, έναν υπερκύβο
με κέντρο ``x_i^c`` και πλευρά ``γ``.

Η αντιστοίχιση ``y_i ⟷ x_i^c`` γίνεται ώστε να κλιμακωθούν οι διαστάσεις των δύο πλεγμάτων και να ταιριάξουν.
Ενώ γενικά επιτρέπεται ``N_{in} $@\not\equal@$ N_{sp}``, δεν υλοποιείται η αντιστοίχιση για τέτοια περίπτωση επειδή δε φαίνεται υψηλής πρακτικής σημασίας.
```julia
xᶜ(yᵢ)= floor.((yᵢ.-1) .* (szᵢₙ./szₛₚ)) .+1
```

Οι τελείες `.` στα ονόματα των συναρτήσεων και των τελεστών επιμερίζουν τη συνάρτηση σε κάθε στοιχείο του διανύσματος ή πίνακα.
Αυτή είναι μια γενική δυνατότητα της Julia και ονομάζεται «broadcasting».

### Ορισμός υπερκύβου

Κάθε μικροστήλη ``y_i`` έχει συνάψεις με μερικά από τα ``x_j \in \mathit{hypercube}(x_i^c,γ)``, επιλεγμένα τυχαία.
Καθώς τα πλέγματα στα οποία εργαζόμαστε έχουν σύνορα, οι υπερκύβοι που βρίσκονται κοντά στα σύνορα θα πρέπει να περιέχουν μόνο τα υπαρκτά στοιχεία του πλέγματος, δηλαδή αυτά που βρίσκονται εντός των συνόρων.
Πλέγμα μεγέθους `sz` έχει σύνορα στο `{1,sz}`.

Ορίζουμε μία δομή που περιγράφει τον υπερκύβο N διαστάσεων, κέντρου ``x^c`` κι ακτίνας ``γ``, εντός πλέγματος μεγέθους `sz`.
Από τη δομή απαιτούμε συγκεκριμένη συμπεριφορά: πρέπει να επιτρέπει τον υπολογισμό όλων των κορυφών που ανήκουν στον υπερκύβο.
Θα μπορούσαμε βεβαίως να υλοποιήσουμε τη δομή ως έναν πίνακα με όλα τα στοιχεία.
Όμως για τόσο απλούς υπολογισμούς είναι πιο συμφέρον να υπολογίζουμε τα στοιχεία επιτόπου.
Έτσι, από τη δομή θα απαιτήσουμε να λειτουργεί ως «επαναλήπτης» (iterator): να ορίζει το πρώτο και το τελευταίο στοιχείο και για κάθε στοιχείο να υπολογίζει το επόμενο.
Υπάρχει μία δομή στη Julia που επιτελεί έναν κοντινό σκοπό, η `CartesianIndices`.
Θα ορίσουμε λοιπόν ένα σύνθετο τύπο που να την περικαλύπτει και να προσφέρει εύκολη κατασκευή και προσπέλαση.

Ο τύπος:
```julia
struct Hypercube{N}
  xᶜ::NTuple{N,Int}
  γ::Int
  sz::NTuple{N,Int}
  indices::CartesianIndices{N}
end
```

Εύκολη κατασκευή:
```julia
Hypercube(xᶜ,γ,sz)= Hypercube(xᶜ,γ,sz, start(xᶜ,γ,sz))
start(xᶜ,γ,sz)= CartesianIndices(map( (a,b)-> a:b,
                    max.(xᶜ .- γ, 1),
                    min.(xᶜ .+ γ, sz) ))
```

Προσπέλαση (διεπαφή επαναλήπτη):
```julia
Base.iterate(hc::Hypercube)= iterate(hc.indices)
Base.iterate(hc::Hypercube,state)= iterate(hc.indices,state)
Base.length(hc::Hypercube)= length(hc.indices)
Base.size(hc::Hypercube)= size(hc.indices)
```

Ας δούμε τι σημεία περιέχει ένας υπερκύβος γύρω από το `(2,2)` με ακτίνα 2 και φραγμένος στο `[1,5]×[1,5]`:
```julia; term= true
using Lazy: @>, @>>
hc= Hypercube((2,2),2,szᵢₙ);
@>> hc collect map(c->c.I)
```
Για ευκολία στη διατύπωση χρησιμοποιούνται οι μακροεντολές `@>, @>>` του πακέτου `Lazy.jl`
που επιτρέπουν την «ύφανση» ορισμάτων στις συναρτήσεις ``@\parencite{innesLazyJl}@``.


## Κατασκευή εγγύς συνάψεων

Οι συνάψεις αναπαρίστανται με έναν πίνακα ``S_{cp} \in \mathbb{B}^{ℓ_{in} × ℓ_{sp}}``
(S: synapse, c: connected, p: proximal).
Για να αρχικοποιήσουμε αυτόν τον πίνακα σύμφωνα με την παραπάνω λογική, πρέπει αρχικά να ορίσουμε τα στοιχεία της τοπολογίας.
