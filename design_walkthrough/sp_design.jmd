# Υλοποίηση του χωρικού συγκεντρωτή

Στην ενότητα ``@\ref{htm:sp}@`` περιγράφηκε ο αλγόριθμος του χωρικού συγκεντρωτή.
Εδώ θα ακολουθήσουμε τη σχεδίαση της υλοποίησής του σε Julia.

## Χώροι εισόδου και εξόδου

Ο χωρικός συγκεντρωτής εμπλέκει ένα ``N_{in}``-διάστατο πεπερασμένο διακριτό πλέγμα στην είσοδο με ένα
``N_{sp}``-διάστατο πεπερασμένο διακριτό πλέγμα στην έξοδο, που αντιπροσωπεύουν τα φλοιικά επίπεδα με κάθε
πλεγματική κορυφή να αντιστοιχίζεται σε μία μικροστήλη.
Το μέγεθος του πλέγματος εισόδου είναι ``\mathit{sz_{in}} \in \mathbb{R}^{N_{in}}``
και του πλέγματος εξόδου ``\mathit{sz_{sp}} \in \mathbb{R}^{N_{sp}}``.
Με βάση αυτό ορίζουμε το μήκος των δύο πλεγμάτων ως ``ℓ_i = \prod \mathit{sz_i}``

Ας ορίσουμε κάποιες διαστάσεις για να χτίσουμε ένα παράδειγμα:
```julia; results= "hidden"
Νᵢₙ= 2
Nₛₚ= 2
szᵢₙ= (5,5)
szₛₚ= (6,9)
```

### Ορισμός συνάρτησης που δέχεται σύμβολα ως όρισμα
``@\label{sp:parametric_types}@``

Ορίσαμε τις διαστάσεις των πλεγμάτων ως σταθερές. Το μήκος των πλεγμάτων όμως δε χρειάζεται να είναι νέες, ανεξάρτητες σταθερές.
Μπορεί να είναι συνάρτηση του ονόματος της διάστασης, ώστε, αν αλλάξουμε τη διάσταση, να αλλάξει και το μήκος.
Ιδανικά, θα θέλαμε να γράφουμε:
```
julia> ℓ(:in)
64

julia> szᵢₙ= (2,40)
(2,40)

julia> ℓ(:in)
80
```

Ο πιο απλός τρόπος να το καταφέρουμε αυτό είναι ο εξής:
```julia; term= true; tangle= false
ℓ(s::Symbol)= if s === :in
  prod(szᵢₙ)
elseif s === :sp
  prod(szₛₚ)
else
  error("Undefined symbol")
end
ℓ(:in)
ℓ(:sp)
```
```julia; tangle= false
ℓ(:random_symbol)
```
Παραπάνω χρησιμοποιήθηκε ο τελεστής της ταύτισης `===`, αντί για τον τελεστή της ισότητας `==`.
Εν προκειμένω θα συμπεριφέρονταν εξίσου, γιατί τα σύμβολα είναι «μοναδικές» (singleton) τιμές.

Ένας εναλλακτικός τρόπος:
```julia; term= true
ℓ(::Val{:in})= prod(szᵢₙ)
ℓ(::Val{:sp})= prod(szₛₚ)
ℓ(s::Symbol)= ℓ(Val(s))
ℓ(:in)
ℓ(:sp)
```
Ο δεύτερος ορισμός χρησιμοποιεί πιο σύνθετα στοιχεία της γλώσσας: παραμετρικούς τύπους και πολλαπλή αποστολή για να επιλέξει τη σωστή μέθοδο (βλέπε ``@\ref{intro:julia_struct}@``).
Ωστόσο, προσφέρει ένα σημαντικό πλεονέκτημα.

Αν θέλουμε να ορίσουμε επιπλέον συμπεριφορά της συνάρτησης για ένα νέο σύμβολο, έστω `:random_symbol`, δε χρειάζεται να ανατρέξουμε στον κώδικα στο σημείο ορισμου της μεθόδου
`ℓ(::Symbol)` και να την τροποποιήσουμε ``@\char"0387@``
αρκεί να ορίσουμε μία νέα μέθοδο:
```julia; term= true
ℓ(::Val{:random_symbol})= rand()
ℓ(:random_symbol)
ℓ(:random_symbol)
```

Καταδεικνύεται έτσι μια βασική σχεδιαστική αρχή στη Julia που βοηθά στην απόπλεξη του κώδικα:
προτιμούμε να ορίζουμε πολλές μικρές μεθόδους και τύπους-περικαλύμματα (wrapping types), όπως εδώ ο `Val`.
``@\bigskip@``

Έστω ``\mathbb{B} = \{0,1\}`` το σύνολο των λογικών τιμών, οπότε ``x \in \mathbb{B}^N``
είναι ένα δυαδικό διάνυσμα μήκους N.

Έστω τα ερεθίσματα εισόδου ``z \in \mathbb{B}^{ℓ_{in}}``
και εξόδου ``a \in \mathbb{B}^{ℓ_{sp}}``.
Τα ``z,a`` αντιστοιχίζουν τα ερεθίσματα με τις κορυφές του πλέγματος, αν ξεδιπλώσουμε
τις διαστάσεις των πλεγμάτων με τη σειρά (column-major).

```julia; results= "hidden"
using Random
z= bitrand(ℓ(:in))
```

### Αντιστοίχιση χώρων εισόδου-εξόδου

Οι μικροστήλες της εισόδου και της εξόδου αντιστοιχίζονται μεταξύ τους μέσω των εγγύς συνάψεων των νευρώνων τους.
Η j-οστή μικροστήλη εισόδου συμβολίζεται ``x_j`` κι η i-οστή μικροστήλη εξόδου ``y_i``.
Ο χώρος της εισόδου θεωρείται στη γενική περίπτωση ότι έχει τοπολογία, η οποία πρέπει να διατηρηθεί στο χώρο εξόδου.
Για αυτό, κάθε ``y_i`` αντιστοιχίζεται σε μία περιοχή της εισόδου, έναν υπερκύβο
με κέντρο ``x_i^c`` και πλευρά ``γ``.

Η αντιστοίχιση ``y_i ⟷ x_i^c`` γίνεται ώστε να κλιμακωθούν οι διαστάσεις των δύο πλεγμάτων και να ταιριάξουν.
Ενώ γενικά επιτρέπεται ``N_{in} $@\not\equal@$ N_{sp}``, δεν υλοποιείται η αντιστοίχιση για τέτοια περίπτωση επειδή δε φαίνεται υψηλής πρακτικής σημασίας.
```julia; results= "hidden"
xᶜ(yᵢ)= floor.(Int, (yᵢ.-1) .* (szᵢₙ./szₛₚ)) .+1
```

Οι τελείες `.` στα ονόματα των συναρτήσεων και των τελεστών επιμερίζουν τη συνάρτηση σε κάθε στοιχείο του διανύσματος ή πίνακα.
Αυτή είναι μια γενική δυνατότητα της Julia και ονομάζεται «broadcasting».

### Ορισμός υπερκύβου

Κάθε μικροστήλη ``y_i`` έχει συνάψεις με μερικά από τα ``x_j \in \mathit{hypercube}(x_i^c,γ)``, επιλεγμένα τυχαία.
Καθώς τα πλέγματα στα οποία εργαζόμαστε έχουν σύνορα, οι υπερκύβοι που βρίσκονται κοντά στα σύνορα θα πρέπει να περιέχουν μόνο τα υπαρκτά στοιχεία του πλέγματος, δηλαδή αυτά που βρίσκονται εντός των συνόρων.
Πλέγμα μεγέθους `sz` έχει σύνορα στο `{1,sz}`.

Ορίζουμε μία δομή που περιγράφει τον υπερκύβο N διαστάσεων, κέντρου ``x^c`` κι ακτίνας ``γ``, εντός πλέγματος μεγέθους `sz`.
Από τη δομή απαιτούμε συγκεκριμένη συμπεριφορά: πρέπει να επιτρέπει τον υπολογισμό όλων των κορυφών που ανήκουν στον υπερκύβο.
Θα μπορούσαμε βεβαίως να υλοποιήσουμε τη δομή ως έναν πίνακα με όλα τα στοιχεία.
Όμως για τόσο απλούς υπολογισμούς είναι πιο συμφέρον να υπολογίζουμε τα στοιχεία επιτόπου.
Έτσι, από τη δομή θα απαιτήσουμε να λειτουργεί ως «επαναλήπτης» (iterator): να ορίζει το πρώτο και το τελευταίο στοιχείο και για κάθε στοιχείο να υπολογίζει το επόμενο.
Υπάρχει μία δομή στη Julia που επιτελεί έναν κοντινό σκοπό, η `CartesianIndices`.
Θα ορίσουμε λοιπόν ένα σύνθετο τύπο που να την περικαλύπτει και να προσφέρει εύκολη κατασκευή και προσπέλαση.

Ο τύπος:
```julia; results= "hidden"
struct Hypercube{N}
  xᶜ::NTuple{N,Int}
  γ::Int
  sz::NTuple{N,Int}
  indices::CartesianIndices{N}
end
```

Εύκολη κατασκευή:
```julia; results= "hidden"
Hypercube(xᶜ,γ,sz)= Hypercube(xᶜ,γ,sz, start(xᶜ,γ,sz))
start(xᶜ,γ,sz)= CartesianIndices(map( (a,b)-> a:b,
                    max.(xᶜ .- γ, 1),
                    min.(xᶜ .+ γ, sz) ))
```

Προσπέλαση (διεπαφή επαναλήπτη):
```julia; results= "hidden"
Base.iterate(hc::Hypercube)= begin
  i= iterate(hc.indices)
  !isnothing(i) ? (i[1].I,i[2]) : nothing
end
Base.iterate(hc::Hypercube,state)= begin
  i= iterate(hc.indices,state)
  !isnothing(i) ? (i[1].I,i[2]) : nothing
end
Base.length(hc::Hypercube)= length(hc.indices)
Base.size(hc::Hypercube)= size(hc.indices)
```

Ας δούμε τι σημεία περιέχει ένας υπερκύβος γύρω από το `(2,2)` με ακτίνα 2 και φραγμένος στο `[1,5]×[1,5]`:
```julia; term= true
using Lazy: @>, @>>
hc= Hypercube((1,2),1,szᵢₙ);
@> hc collect
```
Για ευκολία στη διατύπωση χρησιμοποιούνται οι μακροεντολές `@>, @>>` του πακέτου `Lazy.jl`
που επιτρέπουν την «ύφανση» ορισμάτων στις συναρτήσεις ``@\parencite{innesLazyJl}@``:
```
f(g(x))     === @> x g f
f(x,g(x,y)) === @>> y g(x) f(x)
```
Η αναστροφή της σειράς γραφής ενδεχομένως να καθιστά την εφαρμογή των συναρτήσεων πιο ευανάγνωστη.


## Κατασκευή εγγύς συνάψεων

Οι εγγύς συνάψεις αναπαρίστανται με έναν πίνακα ``W_p \in \mathbb{B}^{ℓ_{in} × ℓ_{sp}}``
Η πρώτη διάσταση, της εισόδου, αντιστοιχεί στους προσυναπτικούς νευρώνες κι η δεύτερη, της εξόδου, στους μετασυναπτικούς.

Αυτός ο πίνακας προκύπτει από τον πίνακα ``D_p \in \mathbb{Sq}^{ℓ_{in} × ℓ_{sp}}`` που περιγράφει τη μονιμότητα κάθε σύναψης:
``@\begin{equation} W_p.= \begin{cases} 1, &D_p .≥ θ_{conn}\\ 0, &D_p .< θ_{conn}  \end{cases} \end{equation}@``

όπου ``\mathbb{Sq}`` είναι το πεδίο κβάντισης των μονιμοτήτων, που δεν απαιτείται να έχουν συνεχείς τιμές.
Στην πράξη, επιλέγουμε ``\mathbb{Sq} = \mathit{\{0x00 .. 0xff\}} = \mathit{UInt8}``, θεωρώντας ότι 256 επίπεδα κβάντισης είναι αρκετά για την ομαλή λειτουργία του αλγορίθμου.
Αυτό όμως είναι ενδιαφέρον σημείο για περισσότερη μελέτη.

Με δεδομένη την τοπολογία μπορούμε να αρχικοποιήσουμε αυτόν τον πίνακα.
Ας ετοιμάσουμε μερικές βοηθητικές συναρτήσεις:

```julia; results= "hidden"
const 𝕊𝕢= UInt8
𝕊𝕢range= 𝕊𝕢(0):typemax(𝕊𝕢)
xᵢ(xᶜ)= Hypercube(xᶜ,γ,szᵢₙ)
# Iterate over the output lattice coordinates
out_lattice()= (c.I for c in CartesianIndices(szₛₚ))
θ_effective()= floor(𝕊𝕢, (1 - θ_potential_prob)*typemax(𝕊𝕢))
# Translate cartesian coordinates to linear indices
c2lᵢₙ= LinearIndices(szᵢₙ)
c2lₛₚ= LinearIndices(szₛₚ)

Wₚ()= Dₚ .> θ_permanence
```

Παράμετροι:
```julia; results= "hidden"
# θ_potential_prob ∈ [0,1]: κατώφλι που εκφράζει το ποσοστό των εγγύς συνάψεων που μπορούν να δημιουργηθούν
# θ_permanence ∈ 𝕊𝕢: κατώφλι σύνδεσης σύναψης
# γ ∈ ℤ: ακτίνα υπερκύβου στο χώρο εισόδου
θ_potential_prob= 0.3
θ_permanence= 0x7f
γ= 2
```

``∀ y_i ∀ x_i(y_i)`` θα λάβουμε ένα τυχαίο αριθμό. Αν είναι κάτω από το κατώφλι `θ_effective`,
δημιουργείται εγγύς σύναψη ``y_i ⟷ x_i`` με τυχαία μονιμότητα.
```julia; results= "hidden"
permanences(xᵢ)= begin
  # Decide randomly if yᵢ ⟷ xᵢ will connect
  p= rand(𝕊𝕢range,length(xᵢ))
  p0= p .> θ_effective(); pScale= p .< θ_effective()
  p[p0].= 𝕊𝕢(0)
  # Draw permanences from uniform distribution in 𝕊𝕢
  p[pScale].= rand(𝕊𝕢range, count(pScale))
  return p
end
fillin_permanences()= begin
  Dₚ= zeros(𝕊𝕢, ℓ(:in),ℓ(:sp))
  foreach(out_lattice()) do yᵢ
    # Linear indices from hypercube
    x= @>> yᵢ xᶜ xᵢ collect map(x->c2lᵢₙ[x...])
    Dₚ[x, c2lₛₚ[yᵢ...]]= permanences(@> yᵢ xᶜ xᵢ)
  end
  return Dₚ
end

Dₚ= fillin_permanences()
```

Ο πίνακας `Dₚ` που μόλις ορίσαμε είναι **η μόνη μεταβλητή κατάστασης** του χωρικού συγκεντρωτή ως τώρα.
Όλοι οι άλλοι κεντρικοί ορισμοί είναι συναρτήσεις, δηλαδή δεν ορίζουν κατάσταση.

Ας οπτικοποιήσουμε τις συνάψεις:
```julia; tangle= false
using Plots; gr()
heatmap(Dₚ)
```


## Ενεργοποίηση Χωρικού Συγκεντρωτή

Στον υπολογισμό της ενεργοποίησης υπάρχουν 3 φάσεις:
- Επικάλυψη ``o(y_i)``, δηλαδή άθροιση ερεθισμάτων για κάθε ``y_i`` μέσω συνδεδεμένων συνάψεων
- Εφαρμογή παρώθησης ``b`` ανά ``y_i``
- Αναστολή μεταξύ ``y_i`` ανά γειτονιά
- Ενεργοποίηση μικροστηλών που κέρδισαν την αναστολή και έχουν ερεθιστεί > από ένα κατώφλι `θ_stimulus_activate`

```julia; results= "hidden"
θ_stimulus_activate= 1
```

### Επικάλυψη

Η παρώθηση είναι συμπληρωματική διαδικασία, οπότε αρχικά την παραλείπουμε.
Η επικάλυψη `o` για κάθε ``y_i`` ως προς την είσοδο `z` είναi απλώς ένας _πολλαπλασιασμός πίνακα × διάνυσμα_.
```julia; results= "hidden"
o(z)= @> Wₚ()'z reshape(szₛₚ)
```

### Τοπική αναστολή

Η αναστολή εφαρμόζεται σε κυλιόμενο παράθυρο του πλέγματος ``y`` ακτίνας ``φ``, που ονομάζεται ακτίνα αναστολής.
Για κάθε παράθυρο, επιλέγουμε τα ``k y_i`` με τη μεγαλύτερη επικάλυψη.
Έστω ``Z(X,p)`` το p-εκατοστημόριο του διανύσματος ``X``.
Η αναστολή παραμετροποιείται από το «ποσοστό τοπικής αραιότητας» ``s`` (συνήθως 2%).
Οπότε ``k≈ \mathit{ceil}(s \mathit{area})``, όπου ``\mathit{area}=(2φ+1)^{Nₛₚ}`` ο αριθμός κορυφών του πλέγματος ``y`` ανά γειτονιά.

Ένας καλός τρόπος για να υπολογίσουμε το ``Z(X,(1-s))`` είναι η μερική ταξινόμηση των επικαλύψεων της γειτονιάς με τον αλγόριθμο «quickselect»:
```julia; results= "hidden"
z!(X)= @> X vec partialsort!(k(),rev=true)
```

Τώρα η επικάλυψη ανά περιοχή γίνεται:
```julia; results= "hidden"
import ImageFiltering: mapwindow, Fill
α(φ)= 2round(Int,φ)+1
k()= ceil(Int, s*α(φ)^Nₛₚ)
Z(o)= mapwindow(z!, o, window(), border= Fill(0))
window()= ntuple(i->α(φ),Nₛₚ)
```

Η σχέση της τοπικής αραιότητας ``s`` και της αραιότητας ολόκληρου του επιπέδου (`sparsity(a)= count(a)/length(a)`) δεν είναι προφανής.
Για μεγάλο ``s`` και ``γ`` τείνει `s ≈ sparsity(a)`.
Όμως για μικρά `s` και ``γ``, επειδή πρέπει ``k ∈ ℤ``, μπορεί το `k` να μην αντιπροσωπεύει ακριβώς το `s`.
Επίσης για μικρό μέγεθος επιπέδων είναι πιθανό πολλά ``y_i`` να έχουν το ίδιο ``o ∈ ℤ``.
Αν ενεργοποιηθούν όλα τα ``y_i | o(y_i) ≥ Z(o,(1-s))``, ή ακόμα και μόνο αυτά που ``o(y_i) > Z(o,(1-s))``,
ενδέχεται να ενεργοποιηθούν αντίστοιχα περισσότερα ή λιγότερα ``y_i`` από ``k``.
Θα μπορούσαμε βέβαια να ενεργοποιήσουμε ακριβώς ``k`` κρατώντας την πρώτη ενεργοποίηση και επιλύοντας τυχαία τις ισοπαλίες.
Πρακτικά αυτή η παρατήρηση δε φαίνεται να επηρεάζει τη λειτουργία του χωρικού συγκεντρωτή,
οπότε επιλέγεται η απλούστερη λύση χωρίς τυχαία επίλυση των ισοπαλιών.

Η ακτίνα αναστολής ``φ`` θεωρητικά είναι δυναμική και αυξάνει καθώς αυξάνεται το μέσο υποδεκτικό πεδίο των μικροστηλών εξόδου.
Όμως στην πράξη η ρύθμιση αυτή φαίνεται να είναι αμελητέα και σε πρώτη ανάλυση αγνοείται.
Ας προσδιορίσουμε λοιπόν την αρχική (και με την προηγούμενη λογική, μόνιμη) τιμή της ``φ`` ως προς την τιμή της αντίστοιχης παραμέτρου ``γ`` του χώρου εισόδου.

Η ``φ`` ανάγει το μέγεθος του μέσου υποδεκτικού πεδίου των μικροστηλών από το χώρο εισόδου στο χώρο εξόδου.
Σύμφωνα με την παραπάνω απλοποίηση, θα προσεγγίσουμε ένα στατικό υποδεκτικό πεδίο από τις παραμέτρους.
```julia; results= "hidden"
using StatsBase: mean, median
receptiveFieldSpan()= (γ*2+0.5)*(1-θ_potential_prob)
receptiveFieldSpan_yspace()= receptiveFieldSpan()*mean(szₛₚ./szᵢₙ)
φ= max((receptiveFieldSpan_yspace()-1)/2, 1)
s= 0.1
```

Με βάση τα παραπάνω, η ενεργοποίηση των μικροστηλών εξόδου είναι:
```julia; results= "hidden"
activate(o)= ((o .>= Z(o)) .& (o .> θ_stimulus_activate))|> vec
```

Άρα η ενεργοποίηση ως προς την είσοδο `z`:
```julia; term= true
reshape(z,szᵢₙ)
a= z|> o|> activate;
reshape(a,szₛₚ)
```

### Παρώθηση

Ο χωρικός συγκεντρωτής χρησιμοποιεί όπως αναφέρθηκε στην ενότητα ``@\ref{htm:sp}@`` ένα μηχανισμό
που αυξάνει την εντροπία της εξόδου, ευαισθητοποιώντας τα ``y_i`` που ενεργοποιούνται σπάνια.
Ο μηχανισμός υλοποιείται με ένα διάνυσμα ``b`` που πολλαπλασιάζει την επικάλυψη των ``y_i`` πριν την εφαρμογή της αναστολής:
```julia; results= "hidden"
o(z)= @> (b() .* Wₚ()'z) reshape(szₛₚ)
```

Το διάνυσμα αυτό προκύπτει από τη μέση δραστηριότητα κάθε ``y_i`` στο χρόνο `åₜ`
και τη μέση δραστηριότητα στη γειτονιά κάθε ``y_i``, `åₙ`.
Εισάγεται έτσι μια νέα μεταβλητή κατάστασης, `åₜ` κι η συνάρτηση μετάβασης/βήματός της.
Για τη συνάρτηση βήματος θα χρησιμοποιηθεί η ίδια λογική με παραμέτρους τύπου που εφαρμόστηκε για το `ℓ` (``@\ref{sp:parametric_types}@``).
Το `åₜ` ανανεώνεται ως εκθετικό φίλτρο κυλιόμενου μέσου όρου με περίοδο `Tboost`.
Το `åₙ` είναι συνάρτηση του `åₜ`: κυλιόμενο φίλτρο εικόνας με πυρήνα μέσου όρου.

```julia; results= "hidden"
using ImageFiltering: imfilter
# Exponential Moving Average
step!(::Val{:åₜ}, åₜ,a)= ( åₜ.= (åₜ.*(Tboost-1) .+ reshape(a,szₛₚ))./Tboost )
# Mean filtering of an image
mean_kernel()= ones(window()) ./ α(φ).^Nₛₚ
åₙ()= imfilter(åₜ, mean_kernel(), "symmetric")
# a convenient wrapper
step!(s::Symbol, args...)= step!(Val(s), args...)
```

Το `b` είναι ως προς αυτά:
```julia; results= "hidden"
b()= @> exp.(-β .* (åₜ.-åₙ())) vec
```

Απαιτούνται δύο νέες παράμετροι, η περίοδος του φίλτρου κυλιόμενου μέσου και η ισχύς της παρώθησης:
```julia; results= "hidden"
Tboost= 200
β= 1
```

Αρχικοποιώντας το `åₜ` με τυχαίες τιμές για να δούμε το αποτέλεσμα, μπορούμε να λάβουμε τη νέα ενεργοποίηση της εξόδου
```julia; term= true
åₜ= rand(szₛₚ...);
reshape(z,szᵢₙ)
reshape(a,szₛₚ)
a_boosted= z|> o|> activate;
reshape(a_boosted,szₛₚ)
```
και να διαπιστώσουμε πώς γίνεται ως τώρα η ενημέρωση της κατάστασης.
```julia; term= true
reshape(åₜ,szₛₚ)
step!(:åₜ, åₜ,a_boosted);
reshape(åₜ,szₛₚ)
@> z o activate reshape(szₛₚ)
```

Είναι σημαντικό να λογαριάζουμε τις μεταβλητές κατάστασης του συστήματος, που ως τώρα είναι 2,
`Dₚ` και `åₜ`, γιατί καθεμία χρειάζεται εφαρμογή συνάρτησης μετάβασης σε κάθε χρονικά βήμα του χωρικού συγκεντρωτή.
Στην επόμενη ενότητα θα ορίσουμε τη συνάρτηση μετάβασης των συνάψεων (εκμάθηση) και θα συγκεντρώσουμε όλες τις συναρτήσεις μετάβασης σε μία, `step!(::Val{:sp})`.


## Εκμάθηση (προσαρμογή συνάψεων)

Οι συνάψεις των ενεργοποιημένων ``y_i`` προσαρμόζονται, ενισχύοντας τις συνάψεις προς τα ενεργά ``x_i``
και εξασθενώντας τις συνάψεις με τα ανενεργά.
Σε αυτόν τον κανόνα όμως εμπίπτουν μόνο οι συνάψεις που απέκτησαν αρχική τιμή ≠0.
Πολλές θέσεις του πίνακα `Dₚ[i,j] == 0` συμβολίζουν έλλειψη σύναψης
``@\footnote{Τα κενά δεν είναι επαρκή εν προκειμένω για να θεωρήσουμε τον Dₚ αραιό}@``
και δεν πρέπει να αλλάξουν.

Ο απλούστερος τρόπος για να το επιτύχουμε είναι ο εξής:
```julia; results= "hidden"
learn!(Dₚ,z,a)= begin
  Dₚ[z,a]  .= (Dₚ[z,a].>0) .* (Dₚ[z,a]   .⊕ p⁺)
  Dₚ[.!z,a].= (Dₚ[z,a].>0) .* (Dₚ[.!z,a] .⊖ p⁻)
end
```

Οι επιπλέον παράμετροι `p⁺, p⁻` εκφράζουν το πόσο αυξομειώνονται οι συνάψεις σε κάθε βήμα εκμάθησης.
```julia; results= "hidden"
p⁺= 0.1; p⁻= 0.02
p⁺= round(𝕊𝕢, p⁺*typemax(𝕊𝕢)); p⁻= round(𝕊𝕢, p⁻*typemax(𝕊𝕢))
```

Οι τελεστές `⊕, ⊖` που εφαρμόζουν τη συναπτική τροποποίηση είναι κορεσμένη πρόσθεση και αφαίρεση αντιστοίχως.
```julia; results= "hidden"
⊕(a::T,b::T) where {T<:Unsigned}= a+b>a ? a+b : typemax(T)
⊖(a::T,b::T) where {T<:Unsigned}= a-b<a ? a-b : one(T)
⊕(a::T,b::T) where {T<:Signed}= a+b>a ? a+b : typemax(T)
⊖(a::T,b::T) where {T<:Signed}= a-b>0 ? a-b : one(T)
```

### Βελτίωση

Βέβαια η παραπάνω μέθοδος δεν είναι πολύ αποδοτική για δύο λόγους:
- προσπελαύνει πολλές φορές έναν εν δυνάμει πολύ μεγάλο πίνακα
- δημιουργεί αντίγραφά του
Το τελευταίο οφείλεται στον τρόπο με τον οποίο λειτουργεί η λήψη στοιχείων από πίνακα στη Julia.
`A[i,j]` σημαίνει δημιουργία ενός νέου πίνακα, μεγέθους `ℓ(i)×ℓ(j)`, με τα στοιχεία που περιέχει ο `A` στην αντίστοιχη περιοχή.

Για να αποφύγουμε αυτή τη συμπεριφορά μπορούμε να χρησιμοποιήσουμε «όψεις» (array views).
Μια βελτιωμένη εκδοχή λοιπόν είναι:
```julia; results= "hidden"
learn!(Dₚ,z,a)= begin
  Dₚactive= @view Dₚ[:,a]   # the only elements we touch
  activeConn=   (Dₚactive .> 0) .&   z
  inactiveConn= (Dₚactive .> 0) .& .!z
  Dₚactive.= activeConn   .* (Dₚactive .⊕ p⁺) .+
             inactiveConn .* (Dₚactive .⊖ p⁻)
end
step!(::Val{:Dₚ}, Dₚ,z,a)= learn!(Dₚ,z,a)
```

Ας δούμε πώς τροποποιούνται οι συνάψεις σε έναν κύκλο ενεργοποίησης του χωρικού συγκεντρωτή.
```julia; term= true; tangle= false
a= z|> o|> activate;
reshape(a,szₛₚ)
D_before= copy(Dₚ);
step!(:Dₚ, Dₚ,z,a);
step!(:åₜ, åₜ,a);
a= z|> o|> activate;
reshape(a,szₛₚ)
```

Στις ενεργές μικροστήλες εξόδου, κάποιες συνάψεις ενισχύονται και κάποιες εξασθενούν:
```julia; tangle= false
D_diff= Int.(Dₚ .> D_before) - Int.(Dₚ .< D_before);
D_diff|> heatmap
```
