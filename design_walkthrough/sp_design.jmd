# Υλοποίηση του χωρικού συγκεντρωτή

Στην ενότητα ``@\ref{htm:sp}@`` περιγράφηκε ο αλγόριθμος του χωρικού συγκεντρωτή.
Εδώ θα ακολουθήσουμε τη σχεδίαση της υλοποίησής του σε Julia.

## Χώροι εισόδου και εξόδου

Ο χωρικός συγκεντρωτής εμπλέκει ένα ``N_{in}``-διάστατο πεπερασμένο διακριτό πλέγμα στην είσοδο με ένα
``N_{sp}``-διάστατο πεπερασμένο διακριτό πλέγμα στην έξοδο, που αντιπροσωπεύουν τα φλοιικά επίπεδα με κάθε
πλεγματική κορυφή να αντιστοιχίζεται σε μία μικροστήλη.
Το μέγεθος του πλέγματος εισόδου είναι ``\mathit{sz_{in}} \in \mathbb{R}^{N_{in}}``
και του πλέγματος εξόδου ``\mathit{sz_{sp}} \in \mathbb{R}^{N_{sp}}``.
Με βάση αυτό ορίζουμε το μήκος των δύο πλεγμάτων ως ``ℓ_i = \prod \mathit{sz_i}``

Ας ορίσουμε κάποιες διαστάσεις για να χτίσουμε ένα παράδειγμα:
```julia; results= "hidden"
Νᵢₙ= 2
Nₛₚ= 2
szᵢₙ= (5,5)
szₛₚ= (6,9)
```

### Ορισμός συνάρτησης που δέχεται σύμβολα ως όρισμα

Ορίσαμε τις διαστάσεις των πλεγμάτων ως σταθερές. Το μήκος των πλεγμάτων όμως δε χρειάζεται να είναι νέες, ανεξάρτητες σταθερές.
Μπορεί να είναι συνάρτηση του ονόματος της διάστασης, ώστε, αν αλλάξουμε τη διάσταση, να αλλάξει και το μήκος.
Ιδανικά, θα θέλαμε να γράφουμε:
```
julia> ℓ(:in)
64

julia> szᵢₙ= (2,40)
(2,40)

julia> ℓ(:in)
80
```

Ο πιο απλός τρόπος να το καταφέρουμε αυτό είναι ο εξής:
```julia; term= true
ℓ(s::Symbol)= if s === :in
  prod(szᵢₙ)
elseif s === :sp
  prod(szₛₚ)
else
  error("Undefined symbol")
end
ℓ(:in)
ℓ(:sp)
```
```julia; tangle= false
ℓ(:random_symbol)
```
Παραπάνω χρησιμοποιήθηκε ο τελεστής της ταύτισης `===`, αντί για τον τελεστή της ισότητας `==`.
Εν προκειμένω θα συμπεριφέρονταν εξίσου, γιατί τα σύμβολα είναι «μοναδικές» (singleton) τιμές.

Ένας εναλλακτικός τρόπος:
```julia; term= true
ℓ(::Val{:in})= prod(szᵢₙ)
ℓ(::Val{:sp})= prod(szₛₚ)
ℓ(s::Symbol)= ℓ(Val(s))
ℓ(:in)
ℓ(:sp)
```
Ο δεύτερος ορισμός χρησιμοποιεί πιο σύνθετα στοιχεία της γλώσσας: παραμετρικούς τύπους και πολλαπλή αποστολή για να επιλέξει τη σωστή μέθοδο (βλέπε ``@\ref{intro:julia_struct}@``).
Ωστόσο, προσφέρει ένα σημαντικό πλεονέκτημα.

Αν θέλουμε να ορίσουμε επιπλέον συμπεριφορά της συνάρτησης για ένα νέο σύμβολο, έστω `:random_symbol`, δε χρειάζεται να ανατρέξουμε στον κώδικα στο σημείο ορισμου της μεθόδου
`ℓ(::Symbol)` και να την τροποποιήσουμε ``@\char"0387@``
αρκεί να ορίσουμε μία νέα μέθοδο:
```julia; term= true
ℓ(::Val{:random_symbol})= rand()
ℓ(:random_symbol)
ℓ(:random_symbol)
```

Καταδεικνύεται έτσι μια βασική σχεδιαστική αρχή στη Julia που βοηθά στην απόπλεξη του κώδικα:
προτιμούμε να ορίζουμε πολλές μικρές μεθόδους και τύπους-περικαλύμματα (wrapping types), όπως εδώ ο `Val`.
``@\bigskip@``

Έστω ``\mathbb{B} = \{0,1\}`` το σύνολο των λογικών τιμών, οπότε ``x \in \mathbb{B}^N``
είναι ένα δυαδικό διάνυσμα μήκους N.

Έστω τα ερεθίσματα εισόδου ``z \in \mathbb{B}^{ℓ_{in}}``
και εξόδου ``a \in \mathbb{B}^{ℓ_{sp}}``.
Τα ``z,a`` αντιστοιχίζουν τα ερεθίσματα με τις κορυφές του πλέγματος, αν ξεδιπλώσουμε
τις διαστάσεις των πλεγμάτων με τη σειρά (column-major).

```julia; results= "hidden"
using Random
z= bitrand(ℓ(:in))
```

### Αντιστοίχιση χώρων εισόδου-εξόδου

Οι μικροστήλες της εισόδου και της εξόδου αντιστοιχίζονται μεταξύ τους μέσω των εγγύς συνάψεων των νευρώνων τους.
Η j-οστή μικροστήλη εισόδου συμβολίζεται ``x_j`` κι η i-οστή μικροστήλη εξόδου ``y_i``.
Ο χώρος της εισόδου θεωρείται στη γενική περίπτωση ότι έχει τοπολογία, η οποία πρέπει να διατηρηθεί στο χώρο εξόδου.
Για αυτό, κάθε ``y_i`` αντιστοιχίζεται σε μία περιοχή της εισόδου, έναν υπερκύβο
με κέντρο ``x_i^c`` και πλευρά ``γ``.

Η αντιστοίχιση ``y_i ⟷ x_i^c`` γίνεται ώστε να κλιμακωθούν οι διαστάσεις των δύο πλεγμάτων και να ταιριάξουν.
Ενώ γενικά επιτρέπεται ``N_{in} $@\not\equal@$ N_{sp}``, δεν υλοποιείται η αντιστοίχιση για τέτοια περίπτωση επειδή δε φαίνεται υψηλής πρακτικής σημασίας.
```julia
xᶜ(yᵢ)= floor.(Int, (yᵢ.-1) .* (szᵢₙ./szₛₚ)) .+1
```

Οι τελείες `.` στα ονόματα των συναρτήσεων και των τελεστών επιμερίζουν τη συνάρτηση σε κάθε στοιχείο του διανύσματος ή πίνακα.
Αυτή είναι μια γενική δυνατότητα της Julia και ονομάζεται «broadcasting».

### Ορισμός υπερκύβου

Κάθε μικροστήλη ``y_i`` έχει συνάψεις με μερικά από τα ``x_j \in \mathit{hypercube}(x_i^c,γ)``, επιλεγμένα τυχαία.
Καθώς τα πλέγματα στα οποία εργαζόμαστε έχουν σύνορα, οι υπερκύβοι που βρίσκονται κοντά στα σύνορα θα πρέπει να περιέχουν μόνο τα υπαρκτά στοιχεία του πλέγματος, δηλαδή αυτά που βρίσκονται εντός των συνόρων.
Πλέγμα μεγέθους `sz` έχει σύνορα στο `{1,sz}`.

Ορίζουμε μία δομή που περιγράφει τον υπερκύβο N διαστάσεων, κέντρου ``x^c`` κι ακτίνας ``γ``, εντός πλέγματος μεγέθους `sz`.
Από τη δομή απαιτούμε συγκεκριμένη συμπεριφορά: πρέπει να επιτρέπει τον υπολογισμό όλων των κορυφών που ανήκουν στον υπερκύβο.
Θα μπορούσαμε βεβαίως να υλοποιήσουμε τη δομή ως έναν πίνακα με όλα τα στοιχεία.
Όμως για τόσο απλούς υπολογισμούς είναι πιο συμφέρον να υπολογίζουμε τα στοιχεία επιτόπου.
Έτσι, από τη δομή θα απαιτήσουμε να λειτουργεί ως «επαναλήπτης» (iterator): να ορίζει το πρώτο και το τελευταίο στοιχείο και για κάθε στοιχείο να υπολογίζει το επόμενο.
Υπάρχει μία δομή στη Julia που επιτελεί έναν κοντινό σκοπό, η `CartesianIndices`.
Θα ορίσουμε λοιπόν ένα σύνθετο τύπο που να την περικαλύπτει και να προσφέρει εύκολη κατασκευή και προσπέλαση.

Ο τύπος:
```julia
struct Hypercube{N}
  xᶜ::NTuple{N,Int}
  γ::Int
  sz::NTuple{N,Int}
  indices::CartesianIndices{N}
end
```

Εύκολη κατασκευή:
```julia
Hypercube(xᶜ,γ,sz)= Hypercube(xᶜ,γ,sz, start(xᶜ,γ,sz))
start(xᶜ,γ,sz)= CartesianIndices(map( (a,b)-> a:b,
                    max.(xᶜ .- γ, 1),
                    min.(xᶜ .+ γ, sz) ))
```

Προσπέλαση (διεπαφή επαναλήπτη):
```julia
Base.iterate(hc::Hypercube)= begin
  i= iterate(hc.indices)
  !isnothing(i) ? (i[1].I,i[2]) : nothing
end
Base.iterate(hc::Hypercube,state)= begin
  i= iterate(hc.indices,state)
  !isnothing(i) ? (i[1].I,i[2]) : nothing
end
Base.length(hc::Hypercube)= length(hc.indices)
Base.size(hc::Hypercube)= size(hc.indices)
```

Ας δούμε τι σημεία περιέχει ένας υπερκύβος γύρω από το `(2,2)` με ακτίνα 2 και φραγμένος στο `[1,5]×[1,5]`:
```julia; term= true
using Lazy: @>, @>>
hc= Hypercube((1,2),1,szᵢₙ);
@> hc collect
```
Για ευκολία στη διατύπωση χρησιμοποιούνται οι μακροεντολές `@>, @>>` του πακέτου `Lazy.jl`
που επιτρέπουν την «ύφανση» ορισμάτων στις συναρτήσεις ``@\parencite{innesLazyJl}@``:
```
f(g(x))     === @> x g f
f(x,g(x,y)) === @>> y g(x) f(x)
```
Η αναστροφή της σειράς γραφής ενδεχομένως να καθιστά την εφαρμογή των συναρτήσεων πιο ευανάγνωστη.


## Κατασκευή εγγύς συνάψεων

Οι συνάψεις αναπαρίστανται με έναν πίνακα ``\mathit{SC}_p \in \mathbb{B}^{ℓ_{in} × ℓ_{sp}}``
(όπου S: synapse, C: connected, p: proximal).
Η πρώτη διάσταση, της εισόδου, αντιστοιχεί στους προσυναπτικούς νευρώνες κι η δεύτερη, της εξόδου, στους μετασυναπτικούς.

Αυτός ο πίνακας προκύπτει από τον πίνακα ``\mathit{SP}_p \in \mathbb{Sq}^{ℓ_{in} × ℓ_{sp}}`` που περιγράφει τη μονιμότητα κάθε σύναψης.
όπου ``\mathbb{Sq}`` είναι το πεδίο κβάντισης των μονιμοτήτων, που δεν απαιτείται να έχουν συνεχείς τιμές.
Στην πράξη, επιλέγουμε ``\mathbb{Sq} = {0x00 .. 0xff} = \mathit{UInt8}``, θεωρώντας ότι 256 επίπεδα κβάντισης είναι αρκετά για την ομαλή λειτουργία του αλγορίθμου.
Αυτό όμως είναι ενδιαφέρον σημείο για περισσότερη μελέτη.

Με δεδομένη την τοπολογία μπορούμε να αρχικοποιήσουμε αυτόν τον πίνακα.
Ας ετοιμάσουμε μερικές βοηθητικές συναρτήσεις:

```julia; results= "hidden"
const 𝕊𝕢= UInt8
𝕊𝕢range= 𝕊𝕢(0):typemax(𝕊𝕢)
xᵢ(xᶜ)= Hypercube(xᶜ,γ,szᵢₙ)
# Iterate over the output lattice coordinates
out_lattice()= (c.I for c in CartesianIndices(szₛₚ))
θ_effective()= floor(𝕊𝕢, (1 - θ_potential_prob_prox)*typemax(𝕊𝕢))
# Translate cartesian coordinates to linear indices
c2lᵢₙ= LinearIndices(szᵢₙ)
c2lₛₚ= LinearIndices(szₛₚ)
```

Παράμετροι:
```julia; results= "hidden"
# θ_potential_prob_prox ∈ [0,1]: κατώφλι που εκφράζει το ποσοστό των εγγύς συνάψεων που μπορούν να δημιουργηθούν
# θ_permanence_prox ∈ 𝕊𝕢: κατώφλι σύνδεσης σύναψης
# γ ∈ ℤ: ακτίνα υπερκύβου στο χώρο εισόδου
θ_potential_prob_prox= 0.3
θ_permanence_prox= 0x7f
γ= 2
```

``∀ y_i ∀ x_i(y_i)`` θα λάβουμε ένα τυχαίο αριθμό. Αν είναι κάτω από το κατώφλι `θ_effective`,
δημιουργείται εγγύς σύναψη ``y_i ⟷ x_i`` με τυχαία μονιμότητα.
```julia; results= "hidden"
permanences(xᵢ)= begin
  # Decide randomly if yᵢ ⟷ xᵢ will connect
  p= rand(𝕊𝕢range,length(xᵢ))
  p0= p .> θ_effective(); pScale= p .< θ_effective()
  p[p0].= 𝕊𝕢(0)
  # Draw permanences from uniform distribution in 𝕊𝕢
  p[pScale].= rand(𝕊𝕢range, count(pScale))
  return p
end
fillin_permanences()= begin
  SPₚ= zeros(𝕊𝕢, ℓ(:in),ℓ(:sp))
  foreach(out_lattice()) do yᵢ
    # Linear indices from hypercube
    x= @>> yᵢ xᶜ xᵢ collect map(x->c2lᵢₙ[x...])
    SPₚ[x, c2lₛₚ[yᵢ...]]= permanences(@> yᵢ xᶜ xᵢ)
  end
  return SPₚ
end

SPₚ= fillin_permanences()
SCₚ= SPₚ .> θ_permanence_prox
```

Ας οπτικοποιήσουμε τις συνάψεις:
```julia
using Plots; gr()
heatmap(SPₚ)
```
