# Υλοποίηση του χωρικού συγκεντρωτή

Στην ενότητα ``@\ref{htm:sp}@`` περιγράφηκε ο αλγόριθμος του χωρικού συγκεντρωτή.
Εδώ θα ακολουθήσουμε τη σχεδίαση της υλοποίησής του σε Julia.

## Χώροι εισόδου και εξόδου

Ο χωρικός συγκεντρωτής εμπλέκει ένα ``N_{in}``-διάστατο πεπερασμένο διακριτό πλέγμα στην είσοδο με ένα
``N_{sp}``-διάστατο πεπερασμένο διακριτό πλέγμα στην έξοδο, που αντιπροσωπεύουν τα φλοιικά επίπεδα με κάθε
πλεγματική κορυφή να αντιστοιχίζεται σε μία μικροστήλη.
Το μέγεθος του πλέγματος εισόδου είναι ``\mathit{sz_{in}} \in \mathbb{R}^{N_{in}}``
και του πλέγματος εξόδου ``\mathit{sz_{sp}} \in \mathbb{R}^{N_{sp}}``.
Με βάση αυτό ορίζουμε το μήκος των δύο πλεγμάτων ως ``ℓ_i = \prod \mathit{sz_i}``

Ας ορίσουμε κάποιες διαστάσεις για να χτίσουμε ένα παράδειγμα:
```julia; results= "hidden"; tangle= false
Νᵢₙ= 2
Nₛₚ= 2
szᵢₙ= (5,5)
szₛₚ= (6,9)
```

### Ορισμός συνάρτησης που δέχεται σύμβολα ως όρισμα
``@\label{sp:parametric_types}@``

Ορίσαμε τις διαστάσεις των πλεγμάτων ως σταθερές. Το μήκος των πλεγμάτων όμως δε χρειάζεται να είναι νέες, ανεξάρτητες σταθερές.
Μπορεί να είναι συνάρτηση του ονόματος της διάστασης, ώστε, αν αλλάξουμε τη διάσταση, να αλλάξει και το μήκος.
Ιδανικά, θα θέλαμε να γράφουμε:
```
julia> ℓ(:in)
64

julia> szᵢₙ= (2,40)
(2,40)

julia> ℓ(:in)
80
```

Ο πιο απλός τρόπος να το καταφέρουμε αυτό είναι ο εξής:
```julia; term= true; tangle= false
ℓ(s::Symbol)= if s === :in
  prod(szᵢₙ)
elseif s === :sp
  prod(szₛₚ)
else
  error("Undefined symbol")
end
ℓ(:in)
ℓ(:sp)
```
```julia; tangle= false
ℓ(:random_symbol)
```
Παραπάνω χρησιμοποιήθηκε ο τελεστής της ταύτισης `===`, αντί για τον τελεστή της ισότητας `==`.
Εν προκειμένω θα συμπεριφέρονταν εξίσου, γιατί τα σύμβολα είναι «μοναδικές» (singleton) τιμές.

Ένας εναλλακτικός τρόπος:
```julia; term= true; tangle= false
ℓ(::Val{:in})= prod(szᵢₙ)
ℓ(::Val{:sp})= prod(szₛₚ)
ℓ(s::Symbol)= ℓ(Val(s))
ℓ(:in)
ℓ(:sp)
```
Ο δεύτερος ορισμός χρησιμοποιεί πιο σύνθετα στοιχεία της γλώσσας: παραμετρικούς τύπους και πολλαπλή αποστολή για να επιλέξει τη σωστή μέθοδο (βλέπε ``@\ref{intro:julia_struct}@``).
Ωστόσο, προσφέρει ένα σημαντικό πλεονέκτημα.

Αν θέλουμε να ορίσουμε επιπλέον συμπεριφορά της συνάρτησης για ένα νέο σύμβολο, έστω `:random_symbol`, δε χρειάζεται να ανατρέξουμε στον κώδικα στο σημείο ορισμου της μεθόδου
`ℓ(::Symbol)` και να την τροποποιήσουμε ``@\char"0387@``
αρκεί να ορίσουμε μία νέα μέθοδο:
```julia; term= true; tangle= false
ℓ(::Val{:random_symbol})= rand()
ℓ(:random_symbol)
ℓ(:random_symbol)
```

Καταδεικνύεται έτσι μια βασική σχεδιαστική αρχή στη Julia που βοηθά στην απόπλεξη του κώδικα:
προτιμούμε να ορίζουμε πολλές μικρές μεθόδους και τύπους-περικαλύμματα (wrapping types), όπως εδώ ο `Val`.
``@\bigskip@``

Έστω ``\mathbb{B} = \{0,1\}`` το σύνολο των λογικών τιμών, οπότε ``x \in \mathbb{B}^N``
είναι ένα δυαδικό διάνυσμα μήκους N.

Έστω τα ερεθίσματα εισόδου ``z \in \mathbb{B}^{ℓ_{in}}``
και εξόδου ``a \in \mathbb{B}^{ℓ_{sp}}``.
Τα ``z,a`` αντιστοιχίζουν τα ερεθίσματα με τις κορυφές του πλέγματος, αν ξεδιπλώσουμε
τις διαστάσεις των πλεγμάτων με τη σειρά (column-major).

```julia; results= "hidden"; tangle= false
using Random
z= bitrand(ℓ(:in))
```

### Αντιστοίχιση χώρων εισόδου-εξόδου

Οι μικροστήλες της εισόδου και της εξόδου αντιστοιχίζονται μεταξύ τους μέσω των εγγύς συνάψεων των νευρώνων τους.
Η j-οστή μικροστήλη εισόδου συμβολίζεται ``x_j`` κι η i-οστή μικροστήλη εξόδου ``y_i``.
Ο χώρος της εισόδου θεωρείται στη γενική περίπτωση ότι έχει τοπολογία, η οποία πρέπει να διατηρηθεί στο χώρο εξόδου.
Για αυτό, κάθε ``y_i`` αντιστοιχίζεται σε μία περιοχή της εισόδου, έναν υπερκύβο
με κέντρο ``x_i^c`` και πλευρά ``γ``.

Η αντιστοίχιση ``y_i ⟷ x_i^c`` γίνεται ώστε να κλιμακωθούν οι διαστάσεις των δύο πλεγμάτων και να ταιριάξουν.
Ενώ γενικά επιτρέπεται ``N_{in} $@\not\equal@$ N_{sp}``, δεν υλοποιείται η αντιστοίχιση για τέτοια περίπτωση επειδή δε φαίνεται υψηλής πρακτικής σημασίας.
```julia; results= "hidden"; tangle= false
xᶜ(yᵢ)= floor.(Int, (yᵢ.-1) .* (szᵢₙ./szₛₚ)) .+1
```

Οι τελείες `.` στα ονόματα των συναρτήσεων και των τελεστών επιμερίζουν τη συνάρτηση σε κάθε στοιχείο του διανύσματος ή πίνακα.
Αυτή είναι μια γενική δυνατότητα της Julia και ονομάζεται «broadcasting».

### Ορισμός υπερκύβου

Κάθε μικροστήλη ``y_i`` έχει συνάψεις με μερικά από τα ``x_j \in \mathit{hypercube}(x_i^c,γ)``, επιλεγμένα τυχαία.
Καθώς τα πλέγματα στα οποία εργαζόμαστε έχουν σύνορα, οι υπερκύβοι που βρίσκονται κοντά στα σύνορα θα πρέπει να περιέχουν μόνο τα υπαρκτά στοιχεία του πλέγματος, δηλαδή αυτά που βρίσκονται εντός των συνόρων.
Πλέγμα μεγέθους `sz` έχει σύνορα στο `{1,sz}`.

Ορίζουμε μία δομή που περιγράφει τον υπερκύβο N διαστάσεων, κέντρου ``x^c`` κι ακτίνας ``γ``, εντός πλέγματος μεγέθους `sz`.
Από τη δομή απαιτούμε συγκεκριμένη συμπεριφορά: πρέπει να επιτρέπει τον υπολογισμό όλων των κορυφών που ανήκουν στον υπερκύβο.
Θα μπορούσαμε βεβαίως να υλοποιήσουμε τη δομή ως έναν πίνακα με όλα τα στοιχεία.
Όμως για τόσο απλούς υπολογισμούς είναι πιο συμφέρον να υπολογίζουμε τα στοιχεία επιτόπου.
Έτσι, από τη δομή θα απαιτήσουμε να λειτουργεί ως «επαναλήπτης» (iterator): να ορίζει το πρώτο και το τελευταίο στοιχείο και για κάθε στοιχείο να υπολογίζει το επόμενο.
Υπάρχει μία δομή στη Julia που επιτελεί έναν κοντινό σκοπό, η `CartesianIndices`.
Θα ορίσουμε λοιπόν ένα σύνθετο τύπο που να την περικαλύπτει και να προσφέρει εύκολη κατασκευή και προσπέλαση.

Ο τύπος:
```julia; results= "hidden"; tangle= false
struct Hypercube{N}
  xᶜ::NTuple{N,Int}
  γ::Int
  sz::NTuple{N,Int}
  indices::CartesianIndices{N}
end
```

Εύκολη κατασκευή:
```julia; results= "hidden"; tangle= false
Hypercube(xᶜ,γ,sz)= Hypercube(xᶜ,γ,sz, start(xᶜ,γ,sz))
start(xᶜ,γ,sz)= CartesianIndices(map( (a,b)-> a:b,
                    max.(xᶜ .- γ, 1),
                    min.(xᶜ .+ γ, sz) ))
```

Προσπέλαση (διεπαφή επαναλήπτη):
```julia; results= "hidden"; tangle= false
Base.iterate(hc::Hypercube)= begin
  i= iterate(hc.indices)
  !isnothing(i) ? (i[1].I,i[2]) : nothing
end
Base.iterate(hc::Hypercube,state)= begin
  i= iterate(hc.indices,state)
  !isnothing(i) ? (i[1].I,i[2]) : nothing
end
Base.length(hc::Hypercube)= length(hc.indices)
Base.size(hc::Hypercube)= size(hc.indices)
```

Ας δούμε τι σημεία περιέχει ένας υπερκύβος γύρω από το `(2,2)` με ακτίνα 2 και φραγμένος στο `[1,5]×[1,5]`:
```julia; term= true; tangle= false
using Lazy: @>, @>>
hc= Hypercube((1,2),1,szᵢₙ);
@> hc collect
```
Για ευκολία στη διατύπωση χρησιμοποιούνται οι μακροεντολές `@>, @>>` του πακέτου `Lazy.jl`
που επιτρέπουν την «ύφανση» ορισμάτων στις συναρτήσεις ``@\parencite{innesLazyJl}@``:
```
f(g(x))     === @> x g f
f(x,g(x,y)) === @>> y g(x) f(x)
```
Η αναστροφή της σειράς γραφής ενδεχομένως να καθιστά την εφαρμογή των συναρτήσεων πιο ευανάγνωστη.


## Κατασκευή εγγύς συνάψεων

Οι εγγύς συνάψεις αναπαρίστανται με έναν πίνακα ``W_p \in \mathbb{B}^{ℓ_{in} × ℓ_{sp}}``
Η πρώτη διάσταση, της εισόδου, αντιστοιχεί στους προσυναπτικούς νευρώνες κι η δεύτερη, της εξόδου, στους μετασυναπτικούς.

Αυτός ο πίνακας προκύπτει από τον πίνακα ``D_p \in \mathbb{Sq}^{ℓ_{in} × ℓ_{sp}}`` που περιγράφει τη μονιμότητα κάθε σύναψης:
``@\begin{equation} W_p.= \begin{cases} 1, &D_p .≥ θ_{conn}\\ 0, &D_p .< θ_{conn}  \end{cases} \end{equation}@``

όπου ``\mathbb{Sq}`` είναι το πεδίο κβάντισης των μονιμοτήτων, που δεν απαιτείται να έχουν συνεχείς τιμές.
Στην πράξη, επιλέγουμε ``\mathbb{Sq} = \mathit{\{0x00 .. 0xff\}} = \mathit{UInt8}``, θεωρώντας ότι 256 επίπεδα κβάντισης είναι αρκετά για την ομαλή λειτουργία του αλγορίθμου.
Αυτό όμως είναι ενδιαφέρον σημείο για περισσότερη μελέτη.

Με δεδομένη την τοπολογία μπορούμε να αρχικοποιήσουμε αυτόν τον πίνακα.
Ας ετοιμάσουμε μερικές βοηθητικές συναρτήσεις:

```julia; results= "hidden"; tangle= false
const 𝕊𝕢= UInt8
𝕊𝕢range= 𝕊𝕢(0):typemax(𝕊𝕢)
xᵢ(xᶜ)= Hypercube(xᶜ,γ,szᵢₙ)
# Iterate over the output lattice coordinates
out_lattice()= (c.I for c in CartesianIndices(szₛₚ))
θ_effective()= floor(𝕊𝕢, (1 - θ_potential_prob)*typemax(𝕊𝕢))
# Translate cartesian coordinates to linear indices
c2lᵢₙ= LinearIndices(szᵢₙ)
c2lₛₚ= LinearIndices(szₛₚ)

Wₚ()= Dₚ .> θ_permanence
```

Παράμετροι:
```julia; results= "hidden"; tangle= false
# θ_potential_prob ∈ [0,1]: κατώφλι που εκφράζει το ποσοστό των εγγύς συνάψεων που μπορούν να δημιουργηθούν
# θ_permanence ∈ 𝕊𝕢: κατώφλι σύνδεσης σύναψης
# γ ∈ ℤ: ακτίνα υπερκύβου στο χώρο εισόδου
θ_potential_prob= 0.3
θ_permanence= 0x7f
γ= 2
```

``∀ y_i ∀ x_i(y_i)`` θα λάβουμε ένα τυχαίο αριθμό. Αν είναι κάτω από το κατώφλι `θ_effective`,
δημιουργείται εγγύς σύναψη ``y_i ⟷ x_i`` με τυχαία μονιμότητα.
```julia; results= "hidden"; tangle= false
permanences(xᵢ)= begin
  # Decide randomly if yᵢ ⟷ xᵢ will connect
  p= rand(𝕊𝕢range,length(xᵢ))
  p0= p .> θ_effective(); pScale= p .< θ_effective()
  p[p0].= 𝕊𝕢(0)
  # Draw permanences from uniform distribution in 𝕊𝕢
  p[pScale].= rand(𝕊𝕢range, count(pScale))
  return p
end
fillin_permanences()= begin
  Dₚ= zeros(𝕊𝕢, ℓ(:in),ℓ(:sp))
  foreach(out_lattice()) do yᵢ
    # Linear indices from hypercube
    x= @>> yᵢ xᶜ xᵢ collect map(x->c2lᵢₙ[x...])
    Dₚ[x, c2lₛₚ[yᵢ...]]= permanences(@> yᵢ xᶜ xᵢ)
  end
  return Dₚ
end

Dₚ= fillin_permanences()
```

Ο πίνακας `Dₚ` που μόλις ορίσαμε είναι **η μόνη μεταβλητή κατάστασης** του χωρικού συγκεντρωτή ως τώρα.
Όλοι οι άλλοι κεντρικοί ορισμοί είναι συναρτήσεις, δηλαδή δεν ορίζουν κατάσταση.

Ας οπτικοποιήσουμε τις συνάψεις:
```julia; tangle= false
using Plots; gr()
heatmap(Dₚ)
```


## Ενεργοποίηση Χωρικού Συγκεντρωτή

Στον υπολογισμό της ενεργοποίησης υπάρχουν 3 φάσεις:
- Επικάλυψη ``o(y_i)``, δηλαδή άθροιση ερεθισμάτων για κάθε ``y_i`` μέσω συνδεδεμένων συνάψεων
- Εφαρμογή παρώθησης ``b`` ανά ``y_i``
- Αναστολή μεταξύ ``y_i`` ανά γειτονιά
- Ενεργοποίηση μικροστηλών που κέρδισαν την αναστολή και έχουν ερεθιστεί > από ένα κατώφλι `θ_stimulus_activate`

```julia; results= "hidden"; tangle= false
θ_stimulus_activate= 1
```

### Επικάλυψη

Η παρώθηση είναι συμπληρωματική διαδικασία, οπότε αρχικά την παραλείπουμε.
Η επικάλυψη `o` για κάθε ``y_i`` ως προς την είσοδο `z` είναi απλώς ένας _πολλαπλασιασμός πίνακα × διάνυσμα_.
```julia; results= "hidden"; tangle= false
o(z)= @> Wₚ()'z reshape(szₛₚ)
```

### Τοπική αναστολή

Η αναστολή εφαρμόζεται σε κυλιόμενο παράθυρο του πλέγματος ``y`` ακτίνας ``φ``, που ονομάζεται ακτίνα αναστολής.
Για κάθε παράθυρο, επιλέγουμε τα ``k y_i`` με τη μεγαλύτερη επικάλυψη.
Έστω ``Z(X,p)`` το p-εκατοστημόριο του διανύσματος ``X``.
Η αναστολή παραμετροποιείται από το «ποσοστό τοπικής αραιότητας» ``s`` (συνήθως 2%).
Οπότε ``k≈ \mathit{ceil}(s \mathit{area})``, όπου ``\mathit{area}=(2φ+1)^{Nₛₚ}`` ο αριθμός κορυφών του πλέγματος ``y`` ανά γειτονιά.

Ένας καλός τρόπος για να υπολογίσουμε το ``Z(X,(1-s))`` είναι η μερική ταξινόμηση των επικαλύψεων της γειτονιάς με τον αλγόριθμο «quickselect»:
```julia; results= "hidden"; tangle= false
z!(X)= @> X vec partialsort!(k(),rev=true)
```

Τώρα η επικάλυψη ανά περιοχή γίνεται:
```julia; results= "hidden"; tangle= false
import ImageFiltering: mapwindow, Fill
α(φ)= 2round(Int,φ)+1
k()= ceil(Int, s*α(φ)^Nₛₚ)
Z(o)= mapwindow(z!, o, window(), border= Fill(0))
window()= ntuple(i->α(φ),Nₛₚ)
```

Η σχέση της τοπικής αραιότητας ``s`` και της αραιότητας ολόκληρου του επιπέδου (`sparsity(a)= count(a)/length(a)`) δεν είναι προφανής.
Για μεγάλο ``s`` και ``γ`` τείνει `s ≈ sparsity(a)`.
Όμως για μικρά `s` και ``γ``, επειδή πρέπει ``k ∈ ℤ``, μπορεί το `k` να μην αντιπροσωπεύει ακριβώς το `s`.
Επίσης για μικρό μέγεθος επιπέδων είναι πιθανό πολλά ``y_i`` να έχουν το ίδιο ``o ∈ ℤ``.
Αν ενεργοποιηθούν όλα τα ``y_i | o(y_i) ≥ Z(o,(1-s))``, ή ακόμα και μόνο αυτά που ``o(y_i) > Z(o,(1-s))``,
ενδέχεται να ενεργοποιηθούν αντίστοιχα περισσότερα ή λιγότερα ``y_i`` από ``k``.
Θα μπορούσαμε βέβαια να ενεργοποιήσουμε ακριβώς ``k`` κρατώντας την πρώτη ενεργοποίηση και επιλύοντας τυχαία τις ισοπαλίες.
Πρακτικά αυτή η παρατήρηση δε φαίνεται να επηρεάζει τη λειτουργία του χωρικού συγκεντρωτή,
οπότε επιλέγεται η απλούστερη λύση χωρίς τυχαία επίλυση των ισοπαλιών.

Η ακτίνα αναστολής ``φ`` θεωρητικά είναι δυναμική και αυξάνει καθώς αυξάνεται το μέσο υποδεκτικό πεδίο των μικροστηλών εξόδου.
Όμως στην πράξη η ρύθμιση αυτή φαίνεται να είναι αμελητέα και σε πρώτη ανάλυση αγνοείται.
Ας προσδιορίσουμε λοιπόν την αρχική (και με την προηγούμενη λογική, μόνιμη) τιμή της ``φ`` ως προς την τιμή της αντίστοιχης παραμέτρου ``γ`` του χώρου εισόδου:
```julia; results= "hidden"; tangle= false
using StatsBase: mean, median
φ= γ*mean(szₛₚ./szᵢₙ)
s= 0.1
```

Με βάση τα παραπάνω, η ενεργοποίηση των μικροστηλών εξόδου είναι:
```julia; results= "hidden"; tangle= false
activate(o)= ((o .>= Z(o)) .& (o .> θ_stimulus_activate))|> vec
```

Άρα η ενεργοποίηση ως προς την είσοδο `z`:
```julia; term= true; tangle= false
reshape(z,szᵢₙ)
a= z|> o|> activate
```

### Παρώθηση

Ο χωρικός συγκεντρωτής χρησιμοποιεί όπως αναφέρθηκε στην ενότητα ``@\ref{htm:sp}@`` ένα μηχανισμό
που αυξάνει την εντροπία της εξόδου, ευαισθητοποιώντας τα ``y_i`` που ενεργοποιούνται σπάνια.
Ο μηχανισμός υλοποιείται με ένα διάνυσμα ``b`` που πολλαπλασιάζει την επικάλυψη των ``y_i`` πριν την εφαρμογή της αναστολής:
```julia; results= "hidden"; tangle= false
o(z)= @> (b() .* Wₚ()'z) reshape(szₛₚ)
```

Το διάνυσμα αυτό προκύπτει από τη μέση δραστηριότητα κάθε ``y_i`` στο χρόνο `åₜ`
και τη μέση δραστηριότητα στη γειτονιά κάθε ``y_i``, `åₙ`.
Εισάγεται έτσι μια νέα μεταβλητή κατάστασης, `åₜ` κι η συνάρτηση μετάβασης/βήματός της.
Για τη συνάρτηση βήματος θα χρησιμοποιηθεί η ίδια λογική με παραμέτρους τύπου που εφαρμόστηκε για το `ℓ` (``@\ref{sp:parametric_types}@``).
Το `åₜ` ανανεώνεται ως εκθετικό φίλτρο κυλιόμενου μέσου όρου με περίοδο `Tboost`.
Το `åₙ` είναι συνάρτηση του `åₜ`: κυλιόμενο φίλτρο εικόνας με πυρήνα μέσου όρου.

```julia; results= "hidden"; tangle= false
using ImageFiltering: imfilter
# Exponential Moving Average
step!(::Val{:åₜ}, åₜ,a)= ( åₜ.= (åₜ.*(Tboost-1) .+ reshape(a,szₛₚ))./Tboost )
# Mean filtering of an image
mean_kernel()= ones(window()) ./ α(φ).^Nₛₚ
åₙ()= imfilter(åₜ, mean_kernel(), "symmetric")
# a convenient wrapper
step!(s::Symbol, args...)= step!(Val(s), args...)
```

Το `b` είναι ως προς αυτά:
```julia; results= "hidden"; tangle= false
b()= @> exp.(-β .* (åₜ.-åₙ())) vec
```

Απαιτούνται δύο νέες παράμετροι, η περίοδος του φίλτρου κυλιόμενου μέσου και η ισχύς της παρώθησης:
```julia; results= "hidden"; tangle= false
Tboost= 200
β= 1
```

Αρχικοποιώντας το `åₜ` με τυχαίες τιμές για να δούμε το αποτέλεσμα, μπορούμε να λάβουμε τη νέα ενεργοποίηση της εξόδου
```julia; term= true; tangle= false
åₜ= rand(szₛₚ...);
reshape(z,szᵢₙ)
a
a_boosted= z|> o|> activate
```
και να διαπιστώσουμε πώς γίνεται ως τώρα η ενημέρωση της κατάστασης.
```julia; term= true; tangle= false
åₜ
step!(:åₜ, åₜ,a_boosted);
åₜ
z|> o|> activate
```

Είναι σημαντικό να λογαριάζουμε τις μεταβλητές κατάστασης του συστήματος, που ως τώρα είναι 2,
`Dₚ` και `åₜ`, γιατί καθεμία χρειάζεται εφαρμογή συνάρτηση μετάβασης σε κάθε χρονικά βήμα του χωρικού συγκεντρωτή.
Στην επόμενη ενότητα θα ορίσουμε τη συνάρτηση μετάβασης των συνάψεων (εκμάθηση) και θα συγκεντρώσουμε όλες τις συναρτήσεις μετάβασης σε μία, `step!(::Val{:sp})`.


## Εκμάθηση (προσαρμογή συνάψεων)

Οι συνάψεις των ενεργοποιημένων ``y_i`` προσαρμόζονται, ενισχύοντας τις συνάψεις προς τα ενεργά ``x_i``
και εξασθενώντας τις συνάψεις με τα ανενεργά.
Σε αυτόν τον κανόνα όμως εμπίπτουν μόνο οι συνάψεις που απέκτησαν αρχική τιμή ≠0.
Πολλές θέσεις του πίνακα `Dₚ[i,j] == 0` συμβολίζουν έλλειψη σύναψης
``@\footnote{Τα κενά δεν είναι επαρκή εν προκειμένω για να θεωρήσουμε τον Dₚ αραιό}@``
και δεν πρέπει να αλλάξουν.

Ο απλούστερος τρόπος για να το επιτύχουμε είναι ο εξής:
```julia; results= "hidden"; tangle= false
learn!(Dₚ,z,a)= begin
  Dₚ[z,a]  .= (Dₚ[z,a].>0) .* (Dₚ[z,a]   .⊕ p⁺)
  Dₚ[.!z,a].= (Dₚ[z,a].>0) .* (Dₚ[.!z,a] .⊖ p⁻)
end
```

Οι επιπλέον παράμετροι `p⁺, p⁻` εκφράζουν το πόσο αυξομειώνονται οι συνάψεις σε κάθε βήμα εκμάθησης.
Οι τελεστές `⊕, ⊖` που εφαρμόζουν τη συναπτική τροποποίηση είναι κορεσμένη πρόσθεση και αφαίρεση αντιστοίχως.
```julia; results= "hidden"; tangle= false
⊕(a::T,b::T) where {T<:Unsigned}= a+b>a ? a+b : typemax(T)
⊖(a::T,b::T) where {T<:Unsigned}= a-b<a ? a-b : one(T)
⊕(a::T,b::T) where {T<:Signed}= a+b>a ? a+b : typemax(T)
⊖(a::T,b::T) where {T<:Signed}= a-b>0 ? a-b : one(T)
```


Βέβαια η παραπάνω μέθοδος δεν είναι πολύ αποδοτική για δύο λόγους:
- προσπελαύνει πολλές φορές έναν εν δυνάμει πολύ μεγάλο πίνακα
- δημιουργεί αντίγραφά του
Το τελευταίο οφείλεται στον τρόπο με τον οποίο λειτουργεί η λήψη στοιχείων από πίνακα στη Julia.
`A[i,j]` σημαίνει δημιουργία ενός νέου πίνακα, μεγέθους `ℓ(i)×ℓ(j)`, με τα στοιχεία που περιέχει ο `A` στην αντίστοιχη περιοχή.

Για να αποφύγουμε αυτή τη συμπεριφορά μπορούμε να χρησιμοποιήσουμε «όψεις» (array views).
Μια βελτιωμένη εκδοχή λοιπόν είναι:
```julia; results= "hidden"; tangle= false
learn!(Dₚ,z,a)= begin
  Dₚactive= @view Dₚ[:,a]   # the only elements we touch
  activeConn=   (Dₚactive .> 0) .&   z
  inactiveConn= (Dₚactive .> 0) .& .!z
  Dₚactive.= activeConn   .* (Dₚactive .⊕ p⁺) .+
             inactiveConn .* (Dₚactive .⊖ p⁻)
end
step!(::Val{:Dₚ}, Dₚ,z,a)= learn!(Dₚ,z,a)
```

Ας δούμε πώς τροποποιούνται οι συνάψεις σε έναν κύκλο ενεργοποίησης του χωρικού συγκεντρωτή.
```julia; term= true; tangle= galse
a= z|> o|> activate
step!(:Dₚ, Dₚ,z,a);
step!(:åₜ, åₜ,a);
a= z|> o|> activate
```


# Σύνθεση στοιχείων χωρικού συγκεντρωτή

Το μόνο εμπόδιο που μένει για τη χρήση του χωρικού συγκεντρωτή είναι ότι οι προηγούμενοι ορισμοί χρησιμοποιούσαν «global» μεταβλητές
για την κατάσταση και για τις παραμέτρους.
Αυτό βοήθησε να απλοποιήσουμε την περιγραφή του αλγορίθμου, αλλά όχι τη χρήση του ως βιβλιοθήκη.
Καθώς ο έλεγχος της κατάστασης είναι κρίσιμος για τη συμπερασματολογία σε οποιοδήποτε πρόγραμμα,
θα πρέπει όλες οι «global» μεταβλητές να εξαλειφθούν.
Οι τρόποι αντιμετώπισης είναι:
- να περικλείσουμε τον ορισμό των περισσότερων εξειδικευμένων συναρτήσεων εντός του πεδίου γενικότερων συναρτήσεων, όπου θα έχουν έμμεση πρόσβαση στα σύμβολα που ορίζουν οι περικλείουσες
- να δώσουμε στις γενικότερες συναρτήσεις που μενουν επιπλέον ορίσματα

_Οι ορισμοί που δίνονται παρακάτω συγκεντρώνουν όλη την υλοποίηση του χωρικού συγκεντρωτή και στέκουν αυτόνομα από τους προηγούμενους._
Δε γίνεται καμία αλλαγή στους αλγορίθμους.

Ορισμοί σταθερών και τύπων υποδομής:
```julia; results= "hidden"
using Random
using Parameters
import Lazy: @>, @>>
import StatsBase: mean, median
import ImageFiltering: mapwindow, Fill, imfilter
# Constants
const 𝕊𝕢= UInt8
const 𝕊𝕢range= 𝕊𝕢(0):typemax(𝕊𝕢)
# Topology
struct Hypercube{N}
  xᶜ::NTuple{N,Int}
  γ::Int
  sz::NTuple{N,Int}
  indices::CartesianIndices{N}
end
Hypercube(xᶜ,γ,sz)= Hypercube(xᶜ,γ,sz, start(xᶜ,γ,sz))
start(xᶜ,γ,sz)= CartesianIndices(map( (a,b)-> a:b,
                    max.(xᶜ .- γ, 1),
                    min.(xᶜ .+ γ, sz) ))
Base.iterate(hc::Hypercube)= begin
  i= iterate(hc.indices)
  !isnothing(i) ? (i[1].I,i[2]) : nothing
end
Base.iterate(hc::Hypercube,state)= begin
  i= iterate(hc.indices,state)
  !isnothing(i) ? (i[1].I,i[2]) : nothing
end
Base.length(hc::Hypercube)= length(hc.indices)
Base.size(hc::Hypercube)= size(hc.indices)
# Infrastructure
ℓ(sz)= prod(sz)
step!(s::Symbol,args...)= step!(Val(s),args...)
```

Ας συνθέσουμε την αρχικοποίηση της κατάστασης και τις παραμέτρους.
```julia; results= "hidden"
@with_kw struct SPParams{Nin,Nsp}
  szᵢₙ::NTuple{Nin,Int}    = (32,32); @assert all(szᵢₙ.>0)
  szₛₚ::NTuple{Nsp,Int}    = (64,64); @assert all(szₛₚ.>0)
  γ::Int                   = 6;       @assert γ>0
  φ::Float32               = γ*mean(szₛₚ./szᵢₙ)
  s::Float32               = .02;     @assert s>0
  θ_potential_prob::Float32= .5;      @assert 0<=θ_potential_prob<=1
  θ_permanence01           = .5;      @assert 0<=θ_permanence01<=1
  p⁺_01                    = .1;      @assert 0<=p⁺_01<=1
  p⁻_01                    = .02;     @assert 0<=p⁻_01<=1
  θ_permanence::𝕊𝕢       = @>> θ_permanence01*typemax(𝕊𝕢) round(𝕊𝕢)
  p⁺::𝕊𝕢                 = round(𝕊𝕢, p⁺_01*typemax(𝕊𝕢))
  p⁻::𝕊𝕢                 = round(𝕊𝕢, p⁻_01*typemax(𝕊𝕢))
  θ_stimulus_activate::Int = 1;       @assert θ_stimulus_activate>=0
  Tboost::Float32          = 200;     @assert Tboost>0
  β::Float32               = 1;       @assert β>0
  @assert φ>=1
  @assert zero(𝕊𝕢)<=θ_permanence<=typemax(𝕊𝕢)
  @assert zero(𝕊𝕢)<=p⁺<=typemax(𝕊𝕢)
  @assert zero(𝕊𝕢)<=p⁻<=typemax(𝕊𝕢)
end
struct SpatialPooler{Nin,Nsp}
  params::SPParams{Nin,Nsp}
  Dₚ::Matrix{𝕊𝕢}
  åₜ::Array{Float32,Nsp}

  SpatialPooler(params::SPParams{Nin,Nsp}) where {Nin,Nsp}= begin
    @unpack szᵢₙ,szₛₚ,θ_potential_prob,γ = params

    xᶜ(yᵢ)= floor.(Int, (yᵢ.-1) .* (szᵢₙ./szₛₚ)) .+1
    xᵢ(xᶜ)= Hypercube(xᶜ,γ,szᵢₙ)
    θ_effective()= floor(𝕊𝕢, (1 - θ_potential_prob)*typemax(𝕊𝕢))
    out_lattice()= (c.I for c in CartesianIndices(szₛₚ))
    permanences(xᵢ)= begin
      # Decide randomly if yᵢ ⟷ xᵢ will connect
      p= rand(𝕊𝕢range,length(xᵢ))
      p0= p .> θ_effective(); pScale= p .< θ_effective()
      p[p0].= 𝕊𝕢(0)
      # Draw permanences from uniform distribution in 𝕊𝕢
      p[pScale].= rand(𝕊𝕢range, count(pScale))
      return p
    end
    fillin_permanences()= begin
      Dₚ= zeros(𝕊𝕢, ℓ(szᵢₙ),ℓ(szₛₚ))
      foreach(out_lattice()) do yᵢ
        # Linear indices from hypercube
        x= @>> yᵢ xᶜ xᵢ collect map(x->c2lᵢₙ[x...])
        Dₚ[x, c2lₛₚ[yᵢ...]]= permanences(@> yᵢ xᶜ xᵢ)
      end
      return Dₚ
    end
    c2lᵢₙ= LinearIndices(szᵢₙ)
    c2lₛₚ= LinearIndices(szₛₚ)

    new{Nin,Nsp}(params,
                 fillin_permanences(),
                 zeros(szₛₚ...))
  end
end
```

Η συνάρτηση ενεργοποίησης γίνεται:
```julia; results= "hidden"
sp_activate(z,sp::SpatialPooler{Nin,Nsp}) where {Nin,Nsp}= begin
  @unpack szₛₚ,s,φ,β,θ_permanence,θ_stimulus_activate = sp.params
  @unpack Dₚ,åₜ = sp
  # overlap
  Wₚ()=  Dₚ .> θ_permanence
  o(z)=  @> (b() .* Wₚ()'z) reshape(szₛₚ)
  # inhibition
  α(φ)=  2round(Int,φ)+1
  k()=   ceil(Int, s*α(φ)^Nsp)
  z!(X)= @> X vec partialsort!(k(),rev=true)
  Z(o)=  mapwindow(z!, o, window(), border= Fill(0))
  # boosting
  window()= ntuple(i->α(φ),Nsp)
  mean_kernel()= ones(window()) ./ α(φ).^Nsp
  åₙ()=  imfilter(åₜ, mean_kernel(), "symmetric")
  b()=   @> exp.(-β .* (åₜ .- åₙ())) vec

  activate(o)= ((o .>= Z(o)) .& (o .> θ_stimulus_activate))|> vec
  z|> o|> activate
end
```

Ας συνθέσουμε τη συνάρτηση βήματος του χωρικού συγκεντρωτή.
Η συνάρτηση λαμβάνει την είσοδο, υπολογίζει την ενεργοποίηση και πραγματοποιεί τις απαιτούμενες μεταβολές κατάστασης.
```julia; results= "hidden"
step!(::Val{:sp}, sp,z)= begin
  a= sp_activate(z,sp)
  step!(:åₜ, sp,a)
  step!(:Dₚ, sp,z,a)
  return a
end
step!(::Val{:åₜ}, sp,a)= begin
  @unpack Tboost, szₛₚ = sp.params
  sp.åₜ.= (sp.åₜ.*(Tboost-1) .+ reshape(a,szₛₚ))./Tboost
end
step!(::Val{:Dₚ}, sp,z,a)= learn!(sp.Dₚ,z,a,sp.params)
learn!(Dₚ,z,a,params)= begin
  @unpack p⁺,p⁻ = params
  Dₚactive= @view Dₚ[:,a]   # the only elements we touch
  activeConn=   (Dₚactive .> 0) .&   z
  inactiveConn= (Dₚactive .> 0) .& .!z
  Dₚactive.= activeConn   .* (Dₚactive .⊕ p⁺) .+
             inactiveConn .* (Dₚactive .⊖ p⁻)
end
# saturated arithmetic
⊕(a::T,b::T) where {T<:Unsigned}= a+b>a ? a+b : typemax(T)
⊖(a::T,b::T) where {T<:Unsigned}= a-b<a ? a-b : one(T)
⊕(a::T,b::T) where {T<:Signed}= a+b>a ? a+b : typemax(T)
⊖(a::T,b::T) where {T<:Signed}= a-b>0 ? a-b : one(T)
```
