# Υλοποίηση της Χρονικής Μνήμης

Για τη χρονική μνήμη το επίπεδο με τις `Ν` μικροστήλες ``y_i`` αναλύεται σε έναν όγκο νευρώνων ``y_{ij}``,
με κάθε μικροστήλη να απαρτίζεται από `k` νευρώνες.
Όπως φάνηκε στο σχήμα ``@\ref{fig:pyramidal_htm_neuron}@``, οι νευρώνες έχουν 3 διαφορετικούς τύπους περιοχών με συνάψεις:
- τις _εγγύς συνάψεις_, που εκφράζουν την αναπαράσταση της εισόδου (προσθιοδρομική ροή πληροφορίας)
- τους εγγύς δενδρίτες με τις _απομακρυσμένες συνάψεις_, που εκφράζουν συμφραζόμενα από το ίδιο επίπεδο,
  πολώνοντας την προσδοκία της επόμενης εισόδου με βάση την προηγούμενη χρονικά είσοδο
- τους κορυφαίους δενδρίτες με τις _κορυφαίες συνάψεις_, που εκφράζουν συμφραζόμενα
  από την έξοδο, πολώνοντας την προσδοκία της επόμενης εισόδου με βάση την αναπαράσταση που σχηματίζει το επόμενο επίπεδο (ανάδραση)

Η λειτουργία και προσαρμογή των εγγύς συνάψεων είναι αντικείμενο του χωρικού συγκεντρωτή.
Η χρονική μνήμη περιγράφει τη λειτουργία και προσαρμογή των απομακρυσμένων συνάψεων,
με το ενδεχόμενο να εμπλέξει με περισσότερη μελέτη και τις κορυφαίες.

Είσοδος της χρονικής μνήμης είναι το σύνολο των ενεργών μικροστηλών `c` που παρήγαγε ο χωρικός συγκεντρωτής.
Έξοδος είναι το σύνολο των ενεργών νευρώνων `α` και το σύνολο των νευρώνων σε προβλεπτική κατάσταση `π`.

Βασική διαφορά στην υλοποίηση των απομακρυσμένων συνάψεων σε σχέση με τις εγγύς είναι η αραιότητά τους.
Κάθε νευρώνας έχει, όπως αναφέρθηκε, πολλούς εγγύς δενδρίτες, με τον καθένα επαρκή να θέσει το νευρώνα σε προβλεπτική κατάσταση.
Οι απομακρυσμένες συνάψεις επομένως συνδέουν προσυναπτικούς _νευρώνες_ με μετασυναπτικούς _δενδρίτες_.
Κάθε δενδρίτης, με τη σειρά του, ανήκει σε ένα νευρώνα.
Τα σχετικά μεγέθη είναι:
- ``N_c`` μικροστήλες
- `k` νευρώνες ανά μικροστήλη
- ``N_n = k N_c`` νευρώνες στο επίπεδο
- ``N_d`` δενδρίτες
Η πολυδιάστατη τοπολογία που ορίστηκε στο χωρικό συγκεντρωτή εδώ δεν παίζει ρόλο.

Για τη μεταγωγή επομένως του μηνύματος από προσυναπτικό νευρώνα σε μετασυναπτικό νευρώνα εμπλέκονται δύο πίνακες:
``W_d ∈ 𝔹^{N_n × N_d}`` των συνδέσεων (συνδεδεμένων συνάψεων) και
``CD ∈ 𝔹^{N_n × N_d}``, πίνακα γειτνίασης νευρώνων-δενδριτών.
Ο ``W_d`` προκύπτει από το ``D_d`` των συναπτικών μονιμοτήτων (d: distal).

Σε υψηλό επίπεδο, η χρονική μνήμη επιτελεί τις εξής διαδικασίες κατά την επεξεργασία μίας εισόδου:
1. ενεργοποίηση νευρώνων
1. προσαρμογή συνάψεων, δημιουργία νέων συνάψεων και δενδριτών
1. υπολογισμός προβλετικών νευρώνων


## Ενεργοποίηση χρονικής μνήμης

Όπως σχολιάστηκε στο σχήμα ``@\ref{fig:tm}@``, ενώ προτεραιότητα στην ενεργοποίηση έχουν οι νευρώνες που ήταν σε προβλετική κατάσταση
την προηγούμενη χρονική στιγμη, αν δεν υπάρχει κανένας τέτοιος σε ενεργή μικροστήλη θα προκληθεί έξαρση ενεργοποίησης όλων των νευρώνων της μικροστήλης.

Η μακροεντολή `@percolumn` αναδιπλώνει το διάνυσμα σε πίνακα με στήλες μήκους `k`
και εφαρμόζει ανά στήλη την αναγωγή του πρώτου ορίσματος.
```julia; results= "hidden"
macro percolumn(reduce,a,k)
  esc(:( $reduce(reshape($a,$k,:),dims=1)|> vec ))
end
```

Η μακροεντολή είναι ουσιαστικά μία συνάρτηση που εκτελείται κατά τη μεταγλώττιση, έχοντας ως ορίσματα _σύμβολα_ και όχι τις τελικές τιμές.
Στο σώμα της μακροεντολής θα μπορούσαν, αν απαιτούνταν, να εκτελεστούν μετασχηματισμοί αυτών των συμβόλων.
Εν προκειμένω μπορούμε κατευθείαν να ορίσουμε την έξοδο της μακροεντολής.
Οι τελεστές `$` θα _παρεμβάλουν_ τις "τιμές" των ορισμάτων της μακροεντολής --- δηλαδή τα σύμβολα με τα οποία την καλέσαμε.
Εποπτικά:
```julia; term= true
m1= @macroexpand @percolumn(sum,a,3)
a= rand(Int8,12);
reshape(a,3,:)
eval(m1)'
```

Σε δεύτερη μορφή, η `@percolumn` αναδιπλώνει το διάνυσμα `a` σε πίνακα με στήλες μήκους `k`
και εφαρμόζει την πράξη `f` ανά στοιχείο με το `b` μήκους `Ncol`:
```julia; results= "hidden"
macro percolumn(f,a,b,k)
  esc(:( $f.(reshape($a,$k,:), $b') ))
end
```

Στην εφαρμογή της `f` παραπάνω χρησιμοποιείται ο μηχανισμός **«broadcasting»** που αναφέρθηκε και νωρίτερα.
Το πρώτο όρισμα στην `f.` έχει διαστάσεις ``k×N_c``, το δεύτερο `1×N_c`.
Ο μηχανισμός αυτός εν προκειμένω θα αναπτύξει τη μοναδιαία διάσταση του δεύτερου ορίσματος για να εφαρμόσει την `f` ανά στοιχείο, χωρίς όμως να δεσμεύσει νέα μνήμη,
_Τέτοια τεχνάσματα επιτρέπουν στη Julia να δημιουργεί αποδοτικούς βρόχους έμμεσα,
δίχως να χρειαστεί ο προγραμματιστής να ορίσει πράξεις δεικτών._

Ας εντοπίσουμε αρχικά ποιες μικροστήλες είναι σε έξαρση, με είσοδο την ενεργοποίηση `c` των μικροστηλών και τους προβλεπτικούς νευρώνες `π`:
```julia; results= "hidden"
burst()= c .& .!@percolumn(any,π, k)
```

Οι στήλες που έχουν προσδοκώμενο νευρώνα και η συνολική ενεργοποίηση:
```julia; results= "hidden"
predicted()= @percolumn(&,π,c, k)
activate()= (predicted() .| burst()')|> vec
```
Με τον ίδιο τρόπο λειτουργεί το «broadcasting» και στην `activate`.

Με αυτά τα εφόδια, ας πειραματιστούμε με την ενεργοποίηση της χρονικής μνήμης:
```julia; term= true
k= 2;
c= [1,0,0,1].==1;
π= [0,0, 1,0, 1,1, 1,0].==1;
burst()
predicted()
reshape(activate(),k,:)
```


## Πρόβλεψη χρονική μνήμης
